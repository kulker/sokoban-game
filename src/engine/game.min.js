// Made with Panda 2 (Engine v2.5.0) - www.panda2.io
var game = {
    audio: null,
    config: {},
    debug: null,
    device: {},
    input: null,
    isStarted: !1,
    json: {},
    keyboard: null,
    logo: null,
    mediaQueue: [],
    modules: {},
    paths: {},
    plugins: {},
    pool: null,
    renderer: null,
    scale: 1,
    storage: null,
    system: null,
    version: "2.5.0",
    _booted: !1,
    _coreModules: ["engine.audio", "engine.camera", "engine.debug", "engine.geometry", "engine.input", "engine.loader", "engine.particle", "engine.physics", "engine.pool", "engine.renderer.core", "engine.scene", "engine.storage", "engine.system", "engine.timer", "engine.tween"],
    _current: null,
    _currentModule: null,
    _DOMLoaded: !1,
    _fnTest: /xyz/.test(function() {}) ? /\bsuper\b/ : /[\D|\d]*/,
    _gameLoopId: 1,
    _gameLoops: {},
    _gameModuleDefined: !1,
    _initializing: !1,
    _loadFinished: !1,
    _logoSource: null,
    _moduleQueue: [],
    _nocache: "",
    _waitForLoad: 0,
    addAsset: function(e, t) {
        if (!(t && this.paths[t] || this.paths[e])) {
            var i = this._getFilePath(e);
            return t && (this.paths[t] = i), this.paths[e] = i, -1 === this.mediaQueue.indexOf(i) && this.mediaQueue.push(i), t
        }
    },
    addAttributes: function(e, t) {
        if (!this[e]) throw "Class " + e + " not found";
        for (var i in t) this[e][i] || (this[e][i] = t[i])
    },
    body: function(e) {
        if (this._current.body = e, !this._booted && 0 !== this._current.name.indexOf("engine.")) return this._current = null, this._boot();
        this._current = null, this._loadFinished && this._loadModules(), this._gameModuleDefined && this._DOMLoaded && !this._loadFinished && this._loadModules()
    },
    copy: function(e) {
        var t, i, s;
        if (!e || "object" != typeof e || e instanceof HTMLElement || e instanceof this.Class || this.Container && e instanceof this.Container) return e;
        if (e instanceof Array) {
            for (i = [], s = 0, t = e.length; s < t; s++) i[s] = this.copy(e[s]);
            return i
        }
        for (s in i = {}, e) i[s] = this.copy(e[s]);
        return i
    },
    createClass: function(e, t, i) {
        if ("object" == typeof e) return this.Class.extend(e);
        if (this[e]) throw "Class " + e + " already created";
        if ("object" == typeof t && (i = t, t = "Class"), !this[t]) throw "Class " + t + " not found";
        return this[e] = this[t].extend(i), this[e]._name = e, this[e]._extend = t, this[e]._content = i, this._currentModule.classes.push({
            name: e,
            extend: t
        }), this[e]
    },
    createScene: function(e, t, i) {
        return "object" == typeof t && (i = t, t = "Scene"), this.createClass(e, t, i)
    },
    defineProperties: function(e, t) {
        if (!this[e]) throw "Class " + e + " not found";
        for (var i in t) Object.defineProperty(this[e].prototype, i, {
            get: t[i].get,
            set: t[i].set
        })
    },
    getJSON: function(e) {
        return this.json[this.paths[e]]
    },
    ksort: function(e, t) {
        if (!e || "object" != typeof e) return !1;
        var i, s = [],
            n = {};
        for (i in e) s.push(i);
        for (s.sort(t), i = 0; i < s.length; i++) n[s[i]] = e[s[i]];
        return n
    },
    merge: function(e, t) {
        for (var i in t) {
            var s = t[i];
            "object" != typeof s || s instanceof HTMLElement || s instanceof this.Class || s instanceof this.Container ? e[i] = s : (e[i] && "object" == typeof e[i] || (e[i] = s instanceof Array ? [] : {}), this.merge(e[i], s))
        }
        return e
    },
    module: function(e) {
        if (this._current) throw "Module " + this._current.name + " has no body";
        if (this.modules[e] && this.modules[e].body) throw "Module " + e + " is already defined";
        if (this._current = {
                name: e,
                requires: [],
                loaded: !1,
                classes: []
            }, 0 === e.indexOf("game.") && (this._gameModuleDefined = !0, this._current.requires.push("engine.core")), this.modules[e] = this._current, this._moduleQueue.push(this._current), "engine.core" === e) {
            if (this.config.ignoreModules)
                for (var t = this._coreModules.length - 1; t >= 0; t--) - 1 !== this.config.ignoreModules.indexOf(this._coreModules[t]) && this._coreModules.splice(t, 1);
            this._current.requires = this._coreModules, this.body(function() {})
        }
        return this
    },
    onReady: function() {},
    onStart: function() {
        this.system.loadScene(this.System.startScene)
    },
    removeAllAssets: function() {
        this.Audio && this.Audio.clearCache(), this.BaseTexture.clearCache(), this.Texture.clearCache(), this.TilingSprite.clearCache(), this.Font.clearCache(), this.json = {}, this.paths = {}
    },
    removeAsset: function(e) {
        if (this.paths[e]) {
            var t = this.paths[e];
            if (-1 !== t.indexOf(".atlas") && this.json[t]) {
                var i = this.json[t];
                for (var s in i.frames) delete game.Texture.cache[s];
                delete game.BaseTexture.cache[game._getFilePath(i.meta.image)]
            }
            game.Audio && game.Audio.cache[t] && delete game.Audio.cache[t], game.BaseTexture.cache[t] && delete game.BaseTexture.cache[t], game.Texture.cache[t] && delete game.Texture.cache[t], game.TilingSprite.cache[t] && (game.TilingSprite.cache[t].baseTexture.remove(), game.TilingSprite.cache[t].remove(), delete game.TilingSprite.cache[t]), this.json[t] && delete this.json[t], delete this.paths[e]
        }
    },
    require: function(e) {
        var t;
        e = Array.prototype.slice.call(arguments);
        for (t = 0; t < e.length; t++) {
            var i = e[t];
            this.config.ignoreModules && -1 !== this.config.ignoreModules.indexOf(i) || i && -1 === this._current.requires.indexOf(i) && this._current.requires.push(i)
        }
        return this
    },
    screenshot: function(e, t, i, s, n) {
        if (this.renderer) {
            t = "number" == typeof t ? t : 0, i = "number" == typeof i ? i : 0, s = s || game.width, n = n || game.height;
            var o = document.createElement("img");
            o.crossOrigin = game.BaseTexture.crossOrigin, o.onload = function() {
                var r = document.createElement("canvas"),
                    a = r.getContext("2d");
                r.width = s, r.height = n, a.drawImage(o, t, i, s, n, 0, 0, s, n), e(r.toDataURL())
            }, o.src = this.renderer.canvas.toDataURL()
        }
    },
    start: function() {
        if (!(this._moduleQueue.length > 0 || this.isStarted)) {
            for (var e in this.system = new this.System, this.input = new this.Input(this.renderer.canvas), this.Keyboard && (this.keyboard = new this.Keyboard), this.Audio && (this.audio = new this.Audio), this.Pool && (this.pool = new this.Pool), this.config.id && !this.Storage.id && (this.Storage.id = this.config.id), this.Storage && this.Storage.id && (this.storage = new this.Storage), this.plugins) this.plugins[e] = new this.plugins[e];
            this.Debug && this.Debug.enabled && (this.debug = new this.Debug);
            var t = document.createElement("canvas");
            t.width = t.height = 120 * game.scale;
            var i = t.getContext("2d");
            i.drawImage(this._logoSource, 0, 0, t.width, t.height / 2), i.rotate(Math.PI), i.translate(-t.width, -t.height), i.drawImage(this._logoSource, 0, 0, t.width, t.height / 2), this.logo = new game.Texture(new game.BaseTexture(t)), this.isStarted = !0, this.system._rotateScreenVisible || this.onStart()
        }
    },
    _boot: function() {
        if (this._booted = !0, this._loadNativeExtensions(), this._loadDeviceInformation(), this._normalizeVendorAttribute(window, "requestAnimationFrame"), this._normalizeVendorAttribute(navigator, "vibrate"), (document.location.href.match(/\?nocache/) || this.config.disableCache) && (this._nocache = "?" + Date.now()), void 0 === this.config.sourceFolder && (this.config.sourceFolder = "src"), void 0 === this.config.mediaFolder && (this.config.mediaFolder = "media"), this.device.mobile) {
            var e = document.getElementsByTagName("meta");
            for (i = 0; i < e.length; i++)
                if ("viewport" === e[i].name) {
                    var t = !0;
                    break
                }
            if (!t) {
                var s = document.createElement("meta");
                s.name = "viewport";
                var n = "width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no";
                this.device.iOS71 && (n += ",minimal-ui"), s.content = n, document.getElementsByTagName("head")[0].appendChild(s)
            }
        }
        this.module("engine.core"), "complete" === document.readyState ? this._DOMReady() : (document.addEventListener("DOMContentLoaded", this._DOMReady.bind(this)), window.addEventListener("load", this._DOMReady.bind(this)))
    },
    _clearGameLoop: function(e) {
        this._gameLoops[e] ? delete this._gameLoops[e] : window.clearInterval(e)
    },
    _DOMReady: function() {
        if (!this._DOMLoaded) {
            if (!document.body) return setTimeout(this._DOMReady.bind(this), 13);
            this._DOMLoaded = !0, this._gameModuleDefined && this._loadModules()
        }
    },
    _getFilePath: function(e) {
        return -1 !== e.indexOf("://") || -1 !== e.indexOf("data:") ? e : (this.config.mediaFolder && (e = this.config.mediaFolder + "/" + e), e)
    },
    _getId: function(e) {
        for (var t in this.paths)
            if (this.paths[t] === e) return t
    },
    _getVendorAttribute: function(e, t) {
        var i = t.ucfirst();
        return e[t] || e["ms" + i] || e["moz" + i] || e["webkit" + i] || e["o" + i]
    },
    _loadDeviceInformation: function() {
        this.device.pixelRatio = window.devicePixelRatio || 1, this.device.screen = {
            width: window.screen.availWidth * this.device.pixelRatio,
            height: window.screen.availHeight * this.device.pixelRatio
        }, this.device.iPod = /iPod/i.test(navigator.userAgent), this.device.iPhone = /iPhone/i.test(navigator.userAgent), this.device.iPhone4 = this.device.iPhone && 2 === this.device.pixelRatio && 920 === this.device.screen.height, this.device.iPhone5 = this.device.iPhone && 2 === this.device.pixelRatio && 1096 === this.device.screen.height, this.device.iPad = /iPad/i.test(navigator.userAgent), this.device.iPadRetina = this.device.iPad && 2 === this.device.pixelRatio, this.device.iOS = this.device.iPod || this.device.iPhone || this.device.iPad, this.device.iOS5 = this.device.iOS && /OS 5/i.test(navigator.userAgent), this.device.iOS6 = this.device.iOS && /OS 6/i.test(navigator.userAgent), this.device.iOS7 = this.device.iOS && /OS 7/i.test(navigator.userAgent), this.device.iOS71 = this.device.iOS && /OS 7_1/i.test(navigator.userAgent), this.device.iOS8 = this.device.iOS && /OS 8/i.test(navigator.userAgent), this.device.iOS9 = this.device.iOS && /OS 9/i.test(navigator.userAgent), this.device.iOS10 = this.device.iOS && /OS 10/i.test(navigator.userAgent), this.device.WKWebView = this.device.iOS && window.webkit && window.webkit.messageHandlers, this.device.android = /android/i.test(navigator.userAgent), this.device.android2 = /android 2/i.test(navigator.userAgent);
        var e = navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        if (this.device.androidStock = !!(e && e[1] < 537), this.device.androidTV = /Android TV/i.test(navigator.userAgent), this.device.ie9 = /MSIE 9/i.test(navigator.userAgent), this.device.ie10 = /MSIE 10/i.test(navigator.userAgent), this.device.ie11 = /rv:11.0/i.test(navigator.userAgent), this.device.ie = this.device.ie10 || this.device.ie11 || this.device.ie9, this.device.edge = /Edge/i.test(navigator.userAgent), this.device.wp7 = /Windows Phone OS 7/i.test(navigator.userAgent), this.device.wp8 = /Windows Phone 8/i.test(navigator.userAgent), this.device.wp = this.device.wp7 || this.device.wp8, this.device.wt = this.device.ie && /Tablet/i.test(navigator.userAgent), this.device.wiiu = /Nintendo WiiU/i.test(navigator.userAgent), this.device.xbox = /Xbox/i.test(navigator.userAgent), this.device.xboxOne = /Xbox One/i.test(navigator.userAgent), this.device.safari = /Safari/i.test(navigator.userAgent), this.device.opera = /Opera/i.test(navigator.userAgent) || /OPR/i.test(navigator.userAgent), this.device.crosswalk = /Crosswalk/i.test(navigator.userAgent), this.device.cocoonJS = !!navigator.isCocoonJS, this.device.cocoonCanvasPlus = /CocoonJS/i.test(navigator.browser), this.device.ejecta = /Ejecta/i.test(navigator.userAgent), this.device.facebook = /FB/i.test(navigator.userAgent), this.device.mobile = this.device.iOS || this.device.android || this.device.wp || this.device.wt, this.device.androidTV && (this.device.mobile = !1), void 0 === navigator.plugins || 0 === navigator.plugins.length)
            if (window.ActiveXObject) try {
                new ActiveXObject("ShockwaveFlash.ShockwaveFlash"), this.device.flash = !0
            } catch (e) {
                this.device.flash = !1
            } else this.device.flash = !1;
            else this.device.flash = !!navigator.plugins["Shockwave Flash"]
    },
    _loadModules: function() {
        var e, t, i, s, n, o;
        for (t = 0; t < this._moduleQueue.length; t++) {
            for (s = this._moduleQueue[t], o = !0, i = 0; i < s.requires.length; i++) n = s.requires[i], this.modules[n] ? this.modules[n].loaded || (o = !1) : (o = !1, this._loadScript(n, s.name));
            o && s.body && (this._moduleQueue.splice(t, 1), s.loaded = !0, this._currentModule = s, s.body(), e = !0, t--, 0 === this._moduleQueue.length && this._ready())
        }
        if (e && this._moduleQueue.length > 0) this._loadModules();
        else {
            if (0 === this._waitForLoad && 0 !== this._moduleQueue.length) {
                var r = [];
                for (t = 0; t < this._moduleQueue.length; t++) {
                    var a = [],
                        h = this._moduleQueue[t].requires;
                    for (i = 0; i < h.length; i++)(s = this.modules[h[i]]) && s.loaded || a.push(h[i]);
                    r.push(this._moduleQueue[t].name + " (requires: " + a.join(", ") + ")")
                }
                throw "Unresolved modules:\n" + r.join("\n")
            }
            this._loadFinished = !0
        }
    },
    _loadNativeExtensions: function() {
        if (Math.distance = function(e, t, i, s) {
                return e = i - e, t = s - t, Math.sqrt(e * e + t * t)
            }, Math._random = Math.random, Math.random = function(e, t) {
                return "number" == typeof t ? Math._random() * (t - e) + e : Math._random(e)
            }, Number.prototype.limit = function(e, t) {
                var i = this;
                return i < e && (i = e), i > t && (i = t), i
            }, Number.prototype.round = function(e) {
                return e = e ? Math.pow(10, e) : 1, Math.round(this * e) / e
            }, Number.prototype.random = function() {
                return Math.random() * this
            }, Array.prototype.erase = function(e) {
                for (var t = this.length; t >= 0; t--)
                    if (this[t] === e) return this.splice(t, 1), this;
                return this
            }, Array.prototype.random = function() {
                return this[Math.floor(Math.random() * this.length)]
            }, Array.prototype.shuffle = function() {
                for (var e = this.length, t = e; t--;) {
                    var i = parseInt(Math.random() * e),
                        s = this[t];
                    this[t] = this[i], this[i] = s
                }
                return this
            }, Array.prototype.last = function() {
                return this[this.length - 1]
            }, Function.prototype.bind = function(e) {
                var t = this,
                    i = [];
                return Array.prototype.push.apply(i, arguments), i.shift(),
                    function() {
                        var s = [];
                        return Array.prototype.push.apply(s, i), Array.prototype.push.apply(s, arguments), t.apply(e, s)
                    }
            }, String.prototype.ucfirst = function() {
                return this.charAt(0).toUpperCase() + this.slice(1)
            }, window.Intl) {
            var e = new Intl.Collator(void 0, {
                numeric: !0,
                sensitivity: "base"
            });
            this.compare = e.compare
        }
    },
    _loadScript: function(e, t) {
        this.modules[e] = !0, this._waitForLoad++;
        var i = e.replace(/\./g, "/") + ".js" + this._nocache;
        this.config.sourceFolder && (i = this.config.sourceFolder + "/" + i);
        var s = document.createElement("script");
        s.type = "text/javascript", s.src = i, s.onload = this._scriptLoaded.bind(this), s.onerror = function() {
            throw "Error loading module " + e + " at " + i + " required from " + t
        }, document.getElementsByTagName("head")[0].appendChild(s)
    },
    _normalizeVendorAttribute: function(e, t) {
        if (!e[t]) {
            var i = this._getVendorAttribute(e, t);
            e[t] = e[t] || i
        }
    },
    _ready: function() {
        for (var e in this.device)
            if (this.device[e] && this.config[e])
                for (var t in this.config[e]) "object" == typeof this.config[e][t] ? (this.config[t] = this.config[t] || {}, this.merge(this.config[t], this.config[e][t])) : this.config[t] = this.config[e][t];
        for (var i in this.config) {
            var s = i.ucfirst();
            if (this[s])
                for (var t in this.config[i]) this[s][t] = this.config[i][t]
        }
        this._logoSource = document.createElement("img"), this._logoSource.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAA8BAMAAABfg2ObAAAALVBMVEUAAAD4uABHR0f4uABHR0f4uAD4uABHR0dHR0dHR0f4uABHR0f4uABHR0f4uADOcJEWAAAADXRSTlMAqqpV6UQkUMmUdBvjKrIhowAAAH1JREFUSMdjKLmLB7gz4Ae++DRfIaD5Ll4wqnlU8xDQzCqIDKRI05z3DgUsIEmzHapmgVHNo5qpovkGInkS1uykhApmo2cMGTyaFRgIAMZRzaOaRzUPJs2sEM0BZGlmSDYGAjMG0jUjwKjmUc2jmontlE0gUXMJckNgA2l6ASc7KJOPBNRIAAAAAElFTkSuQmCC", this._logoSource.onload = this._readyLogo.bind(this)
    },
    _readyLogo: function() {
        this.onReady() || !1 !== this.config.autoStart && this.start()
    },
    _scriptLoaded: function() {
        this._waitForLoad--, this._loadModules()
    },
    _setGameLoop: function(e) {
        if (this.System.frameRate) return window.setInterval(e, 1e3 / this.System.frameRate);
        if (window.requestAnimationFrame) {
            var t = this._gameLoopId++;
            this._gameLoops[t] = !0;
            var i = function() {
                game._gameLoops[t] && (window.requestAnimationFrame(i), e())
            };
            return window.requestAnimationFrame(i), t
        }
        return window.setInterval(e, 1e3 / 60)
    },
    _setVendorAttribute: function(e, t, i) {
        var s = t.ucfirst();
        e[t] = e["ms" + s] = e["moz" + s] = e["webkit" + s] = e["o" + s] = i
    },
    Class: function() {}
};
game.Class.extend = function(e) {
    var t = this.prototype;
    game._initializing = !0;
    var i = new this;
    game._initializing = !1;
    var s = function(e, i) {
        return function() {
            var s = this.super;
            this.super = t[e];
            var n = i.apply(this, arguments);
            return this.super = s, n
        }
    };
    for (var n in e) "function" == typeof e[n] && "function" == typeof t[n] && game._fnTest.test(e[n]) ? i[n] = s(n, e[n]) : i[n] = e[n];

    function o() {
        if (game._initializing) return this;
        for (var e in this) "object" == typeof this[e] && (this[e] = game.copy(this[e]));
        var t = !1;
        this.staticInit && (t = this.staticInit.apply(this, arguments));
        var i = !1;
        return this.init && !t && (i = this.init.apply(this, arguments)), !i && game.scene && "function" == typeof this.update && this !== game.scene && game.scene.addObject(this), this
    }
    return o.prototype = i, o.prototype.constructor = o, o.extend = game.Class.extend, o.inject = function(e) {
        var t = this.prototype,
            i = {},
            s = function(e, t) {
                return function() {
                    var s = this.super;
                    this.super = i[e];
                    var n = t.apply(this, arguments);
                    return this.super = s, n
                }
            };
        for (var n in e) "function" == typeof e[n] && "function" == typeof t[n] && game._fnTest.test(e[n]) ? (i[n] = t[n], t[n] = s(n, e[n])) : t[n] = e[n]
    }, o
}, "undefined" != typeof exports && (exports = module.exports = game);
game.module("engine.tween").body(function() {
    var t;
    game.createClass("Tween", {
        chainedTweens: [],
        currentTime: 0,
        delayRepeat: !1,
        delayTime: 0,
        duration: 1e3,
        easingFunction: null,
        interpolationFunction: null,
        object: null,
        onCompleteCallback: null,
        onRepeatCallback: null,
        onStartCallback: null,
        onUpdateCallback: null,
        paused: !1,
        playing: !1,
        repeatCount: 0,
        reversed: !1,
        yoyoEnabled: !1,
        _onStartCallbackFired: !1,
        _originalStartTime: null,
        _repeats: 0,
        _shouldRemove: !1,
        _startTime: null,
        _valuesEnd: null,
        _valuesStart: {},
        _valuesStartRepeat: {},
        staticInit: function(t) {
            if ("object" != typeof t) throw "Tween parameter must be object";
            for (var e in this.object = t, this.easingFunction = game.Tween.Easing.Linear.None, this.interpolationFunction = game.Tween.Interpolation.Linear, t) "number" == typeof t[e] && (this._valuesStart[e] = parseFloat(t[e], 10))
        },
        chain: function() {
            return this.chainedTweens = arguments, this
        },
        delay: function(t, e) {
            return this.delayTime = t, this.delayRepeat = !!e, this
        },
        easing: function(t) {
            return "string" == typeof t ? (t = t.split("."), this.easingFunction = game.Tween.Easing[t[0]][t[1]]) : this.easingFunction = t, this
        },
        interpolation: function(t) {
            return this.interpolationFunction = t, this
        },
        onComplete: function(t) {
            return this.onCompleteCallback = t, this
        },
        onRepeat: function(t) {
            return this.onRepeatCallback = t, this
        },
        onStart: function(t) {
            return this.onStartCallback = t, this
        },
        onUpdate: function(t) {
            return this.onUpdateCallback = t, this
        },
        pause: function() {
            this.paused = !0
        },
        repeat: function(t) {
            return void 0 === t && (t = 1 / 0), this.repeatCount = t, this
        },
        resume: function() {
            this.paused = !1
        },
        start: function() {
            for (var t in game.scene && game.scene.tweens.push(this), this.currentTime = 0, this.playing = !0, this._onStartCallbackFired = !1, this._startTime = this.delayTime, this._originalStartTime = this._startTime, this._valuesEnd) {
                if (this._valuesEnd[t] instanceof Array) {
                    if (0 === this._valuesEnd[t].length) continue;
                    this._valuesEnd[t] = [this.object[t]].concat(this._valuesEnd[t])
                }
                this._valuesStart[t] = this.object[t], this._valuesStart[t] instanceof Array == !1 && (this._valuesStart[t] *= 1), this._valuesStartRepeat[t] = this._valuesStart[t] || 0
            }
            return this
        },
        stop: function() {
            return this.playing ? (this.playing = !1, this._shouldRemove = !0, this._stopChainedTweens(), this) : this
        },
        to: function(t, e) {
            return this.duration = e || this.duration, this._valuesEnd = t, this
        },
        yoyo: function(t) {
            return void 0 === t && (t = !0), this.yoyoEnabled = t, this
        },
        _stopChainedTweens: function() {
            for (var t = 0, e = this.chainedTweens.length; t < e; t++) this.chainedTweens[t].stop()
        },
        _update: function() {
            if (this._shouldRemove) return !1;
            if (this.paused) return !0;
            if (this.currentTime += 1e3 * game.delta, this.currentTime < this._startTime) return !0;
            !1 === this._onStartCallbackFired && (null !== this.onStartCallback && this.onStartCallback.call(this.object), this._onStartCallbackFired = !0);
            var t = (this.currentTime - this._startTime) / this.duration;
            t = t > 1 ? 1 : t;
            var e, n = this.easingFunction(t);
            for (e in this._valuesEnd) {
                var i = this._valuesStart[e] || 0,
                    a = this._valuesEnd[e];
                a instanceof Array ? this.object[e] = this.interpolationFunction(a, n) : ("string" == typeof a && (a = i + parseFloat(a, 10)), "number" == typeof a && (this.object[e] = i + (a - i) * n))
            }
            if (null !== this.onUpdateCallback && this.onUpdateCallback.call(this.object, n), 1 === t) {
                if (this.repeatCount > 0) {
                    for (e in isFinite(this.repeatCount) && this.repeatCount--, this._repeats += 1, this._valuesStartRepeat) {
                        if ("string" == typeof this._valuesEnd[e] && (this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(this._valuesEnd[e], 10)), this.yoyoEnabled) {
                            var r = this._valuesStartRepeat[e];
                            this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = r, this.reversed = !this.reversed
                        }
                        this._valuesStart[e] = this._valuesStartRepeat[e]
                    }
                    return this.delayRepeat || (this.delayTime = 0), this._startTime = this._originalStartTime + this._repeats * (this.duration + this.delayTime), null !== this.onRepeatCallback && this.onRepeatCallback.call(this.object), !0
                }
                this.playing = !1, "function" == typeof this.onCompleteCallback && this.onCompleteCallback.call(this.object);
                for (var s = 0, o = this.chainedTweens.length; s < o; s++) this.chainedTweens[s].start();
                return !1
            }
            return !0
        }
    }), game.addAttributes("Tween", {
        add: function(t, e, n, i) {
            var a = new game.Tween(t);
            for (var r in a.to(e, n), i) {
                if (!a[r]) throw "Invalid Tween setting: " + r;
                a[r](i[r])
            }
            return a
        },
        Easing: {
            Linear: {
                None: function(t) {
                    return t
                }
            },
            Quadratic: {
                In: function(t) {
                    return t * t
                },
                Out: function(t) {
                    return t * (2 - t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                }
            },
            Cubic: {
                In: function(t) {
                    return t * t * t
                },
                Out: function(t) {
                    return --t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                }
            },
            Quartic: {
                In: function(t) {
                    return t * t * t * t
                },
                Out: function(t) {
                    return 1 - --t * t * t * t
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                }
            },
            Quintic: {
                In: function(t) {
                    return t * t * t * t * t
                },
                Out: function(t) {
                    return --t * t * t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                }
            },
            Sinusoidal: {
                In: function(t) {
                    return 1 - Math.cos(t * Math.PI / 2)
                },
                Out: function(t) {
                    return Math.sin(t * Math.PI / 2)
                },
                InOut: function(t) {
                    return .5 * (1 - Math.cos(Math.PI * t))
                }
            },
            Exponential: {
                In: function(t) {
                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                },
                Out: function(t) {
                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                }
            },
            Circular: {
                In: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                },
                Out: function(t) {
                    return Math.sqrt(1 - --t * t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                }
            },
            Elastic: {
                In: function(t) {
                    var e, n = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (!n || n < 1 ? (n = 1, e = .1) : e = .4 * Math.asin(1 / n) / (2 * Math.PI), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
                },
                Out: function(t) {
                    var e, n = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (!n || n < 1 ? (n = 1, e = .1) : e = .4 * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
                },
                InOut: function(t) {
                    var e, n = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (!n || n < 1 ? (n = 1, e = .1) : e = .4 * Math.asin(1 / n) / (2 * Math.PI), (t *= 2) < 1 ? n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
                }
            },
            Back: {
                In: function(t) {
                    var e = 1.70158;
                    return t * t * ((e + 1) * t - e)
                },
                Out: function(t) {
                    var e = 1.70158;
                    return --t * t * ((e + 1) * t + e) + 1
                },
                InOut: function(t) {
                    var e = 2.5949095;
                    return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                }
            },
            Bounce: {
                In: function(t) {
                    return 1 - game.Tween.Easing.Bounce.Out(1 - t)
                },
                Out: function(t) {
                    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                },
                InOut: function(t) {
                    return t < .5 ? .5 * game.Tween.Easing.Bounce.In(2 * t) : .5 * game.Tween.Easing.Bounce.Out(2 * t - 1) + .5
                }
            }
        },
        Interpolation: {
            Linear: function(t, e) {
                var n = t.length - 1,
                    i = n * e,
                    a = Math.floor(i),
                    r = game.Tween.Interpolation.Utils.Linear;
                return e < 0 ? r(t[0], t[1], i) : e > 1 ? r(t[n], t[n - 1], n - i) : r(t[a], t[a + 1 > n ? n : a + 1], i - a)
            },
            Bezier: function(t, e) {
                var n, i = 0,
                    a = t.length - 1,
                    r = Math.pow,
                    s = game.Tween.Interpolation.Utils.Bernstein;
                for (n = 0; n <= a; n++) i += r(1 - e, a - n) * r(e, n) * t[n] * s(a, n);
                return i
            },
            CatmullRom: function(t, e) {
                var n = t.length - 1,
                    i = n * e,
                    a = Math.floor(i),
                    r = game.Tween.Interpolation.Utils.CatmullRom;
                return t[0] === t[n] ? (e < 0 && (a = Math.floor(i = n * (1 + e))), r(t[(a - 1 + n) % n], t[a], t[(a + 1) % n], t[(a + 2) % n], i - a)) : e < 0 ? t[0] - (r(t[0], t[0], t[1], t[1], -i) - t[0]) : e > 1 ? t[n] - (r(t[n], t[n], t[n - 1], t[n - 1], i - n) - t[n]) : r(t[a ? a - 1 : 0], t[a], t[n < a + 1 ? n : a + 1], t[n < a + 2 ? n : a + 2], i - a)
            },
            Utils: {
                Linear: function(t, e, n) {
                    return (e - t) * n + t
                },
                Bernstein: function(t, e) {
                    var n = game.Tween.Interpolation.Utils.Factorial;
                    return n(t) / n(e) / n(t - e)
                },
                Factorial: (t = [1], function(e) {
                    var n, i = 1;
                    if (t[e]) return t[e];
                    for (n = e; n > 1; n--) i *= n;
                    return t[e] = i
                }),
                CatmullRom: function(t, e, n, i, a) {
                    var r = .5 * (n - t),
                        s = .5 * (i - e),
                        o = a * a;
                    return (2 * e - 2 * n + r + s) * (a * o) + (-3 * e + 3 * n - 2 * r - s) * o + r * a + e
                }
            }
        },
        getTweensForObject: function(t) {
            var e = [];
            if (!game.scene) return e;
            for (var n = game.scene.tweens.length - 1; n >= 0; n--) {
                var i = game.scene.tweens[n];
                i.object === t && e.push(i)
            }
            return e
        },
        stopTweensForObject: function(t) {
            if (game.scene)
                for (var e = game.scene.tweens.length - 1; e >= 0; e--) {
                    var n = game.scene.tweens[e];
                    n.object === t && n.stop()
                }
        }
    }), game.createClass("TweenGroup", {
        onComplete: null,
        tweens: [],
        _complete: !1,
        staticInit: function(t) {
            this.onComplete = t
        },
        add: function(t) {
            return t.onComplete(this._tweenComplete.bind(this)), this.tweens.push(t), t
        },
        pause: function() {
            for (var t = 0; t < this.tweens.length; t++) this.tweens[t].pause()
        },
        remove: function(t) {
            this.tweens.erase(t)
        },
        resume: function() {
            for (var t = 0; t < this.tweens.length; t++) this.tweens[t].resume()
        },
        start: function() {
            for (var t = 0; t < this.tweens.length; t++) this.tweens[t].start()
        },
        stop: function(t, e) {
            if (!this._complete) {
                for (var n = 0; n < this.tweens.length; n++) this.tweens[n].stop(e);
                !this._complete && t && this._tweenComplete(), this._complete = !0
            }
        },
        _tweenComplete: function() {
            if (!this._complete) {
                for (var t = 0; t < this.tweens.length; t++)
                    if (this.tweens[t].playing) return;
                this._complete = !0, "function" == typeof this.onComplete && this.onComplete()
            }
        }
    })
});
game.module("engine.timer").body(function() {
    game.createClass("Timer", {
        callback: null,
        repeat: !1,
        target: 0,
        _base: 0,
        _last: 0,
        _pause: 0,
        init: function(e) {
            this._last = game.Timer.time, this.set(e)
        },
        clear: function() {
            this.callback = null, this.repeat = !1, this.set(0)
        },
        delta: function() {
            var e = game.Timer.time - this._last;
            return this._last = game.Timer.time, this._pause ? 0 : e
        },
        pause: function() {
            this._pause || (this._pause = game.Timer.time)
        },
        reset: function() {
            this._base = game.Timer.time, this._pause = 0
        },
        resume: function() {
            this._pause && (this._base += game.Timer.time - this._pause, this._pause = 0)
        },
        set: function(e) {
            "number" != typeof e && (e = 0), this.target = e, this.reset()
        },
        time: function() {
            var e = this._base + this.target - (this._pause || game.Timer.time);
            return e < 0 ? 0 : e
        }
    }), game.addAttributes("Timer", {
        delta: 0,
        minFPS: 20,
        speed: 1,
        time: 0,
        _last: 0,
        _lastFrameTime: 0,
        _realDelta: 0,
        add: function(e, t, i, a) {
            var s = new game.Timer(e);
            return s.repeat = !!i, s.callback = t, game.scene.timers.push(s), a && t(), s
        },
        update: function() {
            var e = Date.now();
            this._last || (this._last = e), this._realDelta = e - this._last, this.delta = Math.min(this._realDelta, 1e3 / this.minFPS) * this.speed, this._lastFrameTime = this.time, this.time += this.delta, this._last = e
        }
    })
});
game.module("engine.system").body(function() {
    game.createClass("System", {
        canvasHeight: 0,
        canvasWidth: 0,
        delta: 0,
        height: 0,
        hires: !1,
        originalHeight: 0,
        originalWidth: 0,
        paused: !1,
        scene: null,
        width: 0,
        _newSceneName: null,
        _pausedOnHide: !1,
        _rotateScreenVisible: !1,
        _runLoopId: 0,
        _running: !1,
        _windowWidth: 0,
        _windowHeight: 0,
        init: function() {
            this._updateWindowSize(), game.width = this.width = this.originalWidth = game.System.width, game.height = this.height = this.originalHeight = game.System.height, game.delta = this.delta;
            var e, i = this.originalWidth,
                t = this.originalHeight;
            game.System.hidpi && (i /= game.device.pixelRatio, t /= game.device.pixelRatio);
            for (var s = 2; s <= game.System.hires; s += 2) {
                var n = game.System.hiresRatio * (s / 2),
                    a = game.System.hiresDeviceSize ? game.device.screen.width : this._windowWidth,
                    h = game.System.hiresDeviceSize ? game.device.screen.height : this._windowHeight;
                a >= i * n && h >= t * n && (this.hires = !0, game.scale = s)
            }
            this.canvasWidth = this.originalWidth * game.scale, this.canvasHeight = this.originalHeight * game.scale, void 0 !== document.hidden ? e = "visibilitychange" : void 0 !== document.mozHidden ? e = "mozvisibilitychange" : void 0 !== document.msHidden ? e = "msvisibilitychange" : void 0 !== document.webkitHidden && (e = "webkitvisibilitychange"), document.addEventListener(e, function() {
                game.System.pauseOnHide && (!!game._getVendorAttribute(document, "hidden") ? game.system.pause(!0) : game.system.resume(!0))
            }), game.System.resize && (game.System.center = !1), this._initRenderer(), game.System.hidpi && (this.canvasWidth /= game.device.pixelRatio, this.canvasHeight /= game.device.pixelRatio), game.device.WKWebView ? window.addEventListener("orientationchange", this._onWindowResize.bind(this)) : window.addEventListener("resize", this._onWindowResize.bind(this)), this._onWindowResize()
        },
        fullscreen: function() {
            game.renderer.canvas.requestFullscreen ? game.renderer.canvas.requestFullscreen() : game.renderer.canvas.requestFullScreen && game.renderer.canvas.requestFullScreen()
        },
        fullscreenSupport: function() {
            return !(!game.renderer.canvas.requestFullscreen && !game.renderer.canvas.requestFullScreen)
        },
        loadScene: function(e) {
            game.mediaQueue.length ? this.setScene(game.System.loader, e) : this.setScene(e)
        },
        resize: function(e, i) {
            this.width === e && this.height === i || (game.width = this.width = e / game.scale, game.height = this.height = i / game.scale, game.renderer._resize(e, i), this.scene && this.scene.onResize && this.scene.onResize())
        },
        pause: function(e) {
            this.paused || (e ? this._pausedOnHide = !0 : this.paused = !0, this.scene && this.scene._pause && this.scene._pause())
        },
        resume: function(e) {
            e && this.paused || (e || this.paused) && (e ? this._pausedOnHide = !1 : this.paused = !1, game.Timer.last = Date.now(), this.scene && this.scene._resume && this.scene._resume())
        },
        setScene: function(e, i) {
            if (!e && this.scene && (e = this.scene.constructor._name), !game[e]) throw "Scene " + e + " not found";
            this._running && !this.paused ? (this._newSceneName = e, this._newSceneParam = i) : this._setSceneNow(e, i)
        },
        _hideRotateScreen: function() {
            this._rotateScreenVisible && (this._rotateScreenVisible = !1, game.renderer._show(), document.body.className = "")
        },
        _initRenderer: function() {
            game.renderer = new game.Renderer(this.canvasWidth, this.canvasHeight)
        },
        _onWindowResize: function() {
            if (this._updateWindowSize(), !this._toggleRotateScreen()) {
                var e = game.System.scalePercent / 100;
                this._scale(this._windowWidth * e, this._windowHeight * e), this._resize(this._windowWidth, this._windowHeight), game.System.center && game.renderer._position((this._windowWidth - this.canvasWidth) / 2, (this._windowHeight - this.canvasHeight) / 2), (game.System.scale || game.System.resize || game.System.hidpi && game.device.pixelRatio > 1) && game.renderer._size(this.canvasWidth, this.canvasHeight), game.isStarted && !game.scene && game.onStart()
            }
        },
        _resize: function(e, i) {
            if (game.System.resize) {
                if (!game.System.scale) return this.resize(e, i), this.canvasWidth = e, void(this.canvasHeight = i);
                var t = e - this.canvasWidth,
                    s = i - this.canvasHeight;
                if (t > 0) {
                    var n = t / this.canvasWidth,
                        a = ~~(this.originalWidth * game.scale + this.originalWidth * n * game.scale);
                    this.resize(a, this.originalHeight * game.scale), this.canvasWidth += t
                } else if (s > 0) {
                    n = s / this.canvasHeight;
                    var h = ~~(this.originalHeight * game.scale + this.originalHeight * n * game.scale);
                    this.resize(this.originalWidth * game.scale, h), this.canvasHeight += s
                }
            }
        },
        _run: function() {
            this.paused || this._pausedOnHide || (game.Timer.update(), game.delta = this.delta = game.Timer.delta / 1e3, game.input._update(), this.scene._update(), this._newSceneName && this._setSceneNow(this._newSceneName, this._newSceneParam))
        },
        _scale: function(e, i) {
            if (game.System.scale && (e / this.originalWidth < i / this.originalHeight ? (this.canvasWidth = e, this.canvasHeight = ~~(e * (this.originalHeight / this.originalWidth))) : (this.canvasWidth = ~~(i * (this.originalWidth / this.originalHeight)), this.canvasHeight = i), game.System.scaleMax > 0)) {
                var t = this.originalWidth * (game.System.scaleMax / 100),
                    s = this.originalHeight * (game.System.scaleMax / 100);
                this.canvasWidth > t && (this.canvasWidth = t), this.canvasHeight > s && (this.canvasHeight = s)
            }
        },
        _setSceneNow: function(e, i) {
            this._newSceneName = null, this.scene && this.scene._exit(e) || (this.paused && (this.paused = !1), game.TilingSprite.clearCache(), this.scene = new game[e](i), this._startRunLoop())
        },
        _showRotateScreen: function() {
            this._rotateScreenVisible || (this._rotateScreenVisible = !0, game.renderer._hide(), document.body.className = game.System.rotateScreenClass)
        },
        _startRunLoop: function() {
            this.scene && (this._runLoopId && this._stopRunLoop(), this._runLoopId = game._setGameLoop(this._run.bind(this)), this._running = !0)
        },
        _stopRunLoop: function() {
            game._clearGameLoop(this._runLoopId), this._running = !1
        },
        _toggleRotateScreen: function() {
            return !(!game.device.mobile || !game.System.rotateScreen) && (this.originalWidth > this.originalHeight && this._windowWidth < this._windowHeight || this.originalHeight > this.originalWidth && this._windowHeight < this._windowWidth ? (this._showRotateScreen(), !0) : (this._hideRotateScreen(), !1))
        },
        _updateWindowSize: function() {
            this._windowWidth = game.device.WKWebView ? document.documentElement.clientWidth : window.innerWidth, this._windowHeight = game.device.WKWebView ? document.documentElement.clientHeight : window.innerHeight, game.device.crosswalk && 0 === this._windowWidth && (this._windowWidth = window.screen.width, this._windowHeight = window.screen.height)
        }
    }), game.addAttributes("System", {
        canvasId: "canvas",
        center: !0,
        frameRate: null,
        height: 768,
        hidpi: !1,
        hires: 0,
        hiresDeviceSize: !1,
        hiresRatio: 2,
        loader: "Loader",
        pauseOnHide: !0,
        resize: !1,
        rotateScreen: !0,
        rotateScreenClass: "rotate",
        scale: !0,
        scaleMax: 0,
        scalePercent: 100,
        startScene: "Main",
        width: 1024
    })
});
game.module("engine.storage").body(function() {
    game.createClass("Storage", {
        id: "",
        supported: !1,
        init: function(t) {
            this.id = t || game.Storage.id, this.supported = this._isSupported()
        },
        clear: function() {
            for (var t = localStorage.length - 1; t >= 0; t--) {
                var e = localStorage.key(t); - 1 !== e.indexOf(this.id + ".") && localStorage.removeItem(e)
            }
        },
        get: function(t, e) {
            var o = localStorage.getItem(this.id + "." + t);
            if (null === o) return e;
            try {
                return this._decode(o)
            } catch (t) {
                return o
            }
        },
        has: function(t) {
            return null !== localStorage.getItem(this.id + "." + t)
        },
        remove: function(t) {
            localStorage.removeItem(this.id + "." + t)
        },
        set: function(t, e) {
            return this.supported && localStorage.setItem(this.id + "." + t, this._encode(e)), e
        },
        _decode: function(t) {
            return JSON.parse(t)
        },
        _encode: function(t) {
            return JSON.stringify(t)
        },
        _isSupported: function() {
            if ("object" != typeof localStorage) return !1;
            try {
                localStorage.setItem("localStorage", 1), localStorage.removeItem("localStorage")
            } catch (t) {
                return !1
            }
            return !0
        }
    }), game.addAttributes("Storage", {
        id: ""
    })
});
game.module("engine.renderer.tilingsprite").require("engine.renderer.sprite").body(function() {
    game.createClass("TilingSprite", "Container", {
        texture: null,
        tilePosition: null,
        _pos: [],
        _rect: [],
        _sprite: null,
        _updateSprites: !1,
        staticInit: function(t, e, i) {
            this.super(), this.tilePosition = new game.Vector, this._pos = new game.Vector, this._rect = new game.Vector, this.texture = this.texture || t, this.texture = this.texture instanceof game.Texture ? this.texture : game.Texture.fromAsset(this.texture), this._width = this._width || e || this.texture.width, this._height = this._height || i || this.texture.height, this._generateSprites()
        },
        updateTransform: function() {
            this.super(), this._updateSprites && this._generateSprites()
        },
        _generateSprites: function() {
            if (this.texture.baseTexture.loaded) {
                this._sprite && (delete game.TilingSprite.cache[this._sprite.texture.baseTexture._id], this._sprite.texture.baseTexture.remove(), this._sprite.texture.remove());
                var t = document.createElement("canvas"),
                    e = t.getContext("2d"),
                    i = Math.ceil(this.width / this.texture.width),
                    h = Math.ceil(this.height / this.texture.height),
                    s = i * this.texture.width,
                    r = h * this.texture.height;
                t.width = s * game.scale, t.height = r * game.scale, this._pos.set(0);
                for (var a = new game.Sprite(this.texture), n = 0; n < h; n++)
                    for (var o = 0; o < i; o++) this._pos.x = o * a.width * game.scale, this._pos.y = n * a.height * game.scale, a._renderCanvas(e, null, null, this._pos);
                var _ = game.Texture.fromCanvas(t);
                this.tw = _.width, this.th = _.height, game.TilingSprite.cache[this.texture.baseTexture._id] = _, this._sprite = new game.Sprite(_), this._sprite._parent = this, this._updateSprites = !1
            }
        },
        _getBounds: function() {
            if (this.rotation) var t = this.width,
                e = this.height,
                i = this._worldTransform,
                h = i.a,
                s = i.b,
                r = i.c,
                a = i.d,
                n = i.tx,
                o = i.ty,
                _ = h * t + n,
                u = s * t + o,
                c = h * t + r * e + n,
                d = a * e + s * t + o,
                g = r * e + n,
                l = a * e + o,
                x = Math.min(n, _, c, g),
                w = Math.min(o, u, d, l),
                p = Math.max(n, _, c, g),
                m = Math.max(o, u, d, l);
            else x = this._worldTransform.tx, w = this._worldTransform.ty, p = x + this.width, m = w + this.height;
            for (var f = 0; f < this.children.length; f++) {
                var T = this.children[f]._getBounds(),
                    v = T.x + T.width,
                    y = T.y + T.height;
                T.x < x && (x = T.x), T.y < w && (w = T.y), v > p && (p = v), y > m && (m = y)
            }
            return this._worldBounds.x = x, this._worldBounds.y = w, this._worldBounds.width = p - x, this._worldBounds.height = m - w, this._worldBounds
        },
        _renderCanvas: function(t) {
            if (!this.texture) return !0;
            if (!this.texture.baseTexture.loaded) return !0;
            if (!this.texture.width && this.texture.baseTexture.width && (this.texture.width = this.texture.baseTexture.width), !this.texture.height && this.texture.baseTexture.height && (this.texture.height = this.texture.baseTexture.height), !this.texture.width || !this.texture.height) return !0;
            var e = this._worldTransform.a / this._cosCache,
                i = this._worldTransform.d / this._cosCache,
                h = this.tw * game.scale,
                s = this.th * game.scale,
                r = this.width / e * game.scale,
                a = this.height / i * game.scale,
                n = this.tilePosition.x * game.scale,
                o = n % h,
                _ = this.tilePosition.y * game.scale % s;
            o > 0 && (o -= h), _ > 0 && (_ -= s);
            for (var u = 0; u < 4 && !(_ >= a); u++) this._rect.x = 0, this._rect.y = 0, this._rect.width = h, this._rect.height = s, this._pos.x = o * e, this._pos.y = _ * i, o + h > r && (this._rect.width = Math.ceil(r - o)), _ + s > a && (this._rect.height = Math.ceil(a - _)), o < 0 && (this._rect.x = -o, this._pos.x = 0), _ < 0 && (this._rect.y = -_, this._pos.y = 0), this._rect.width > r && (this._rect.width = r), this._rect.height > a && (this._rect.height = a), this._rect.x + this._rect.width > h && (this._rect.width = h - this._rect.x), this._rect.y + this._rect.height > s && (this._rect.height = s - this._rect.y), this._sprite._worldAlpha = this._worldAlpha, this._sprite._renderCanvas(t, this._worldTransform, this._rect, this._pos), (o += h) >= r && ((o = n % h) > 0 && (o -= h), _ += s)
        }
    }), game.addAttributes("TilingSprite", {
        cache: {},
        clearCache: function() {
            for (var t in this.cache) this.cache[t].baseTexture.remove(), this.cache[t].remove(), delete this.cache[t]
        }
    }), game.defineProperties("TilingSprite", {
        width: {
            get: function() {
                var t = this._worldTransform.a / this._cosCache;
                return this._width * t
            },
            set: function(t) {
                this._width !== t && (this._updateSprites = !0), this._width = t
            }
        },
        height: {
            get: function() {
                var t = this._worldTransform.d / this._cosCache;
                return this._height * t
            },
            set: function(t) {
                this._height !== t && (this._updateSprites = !0), this._height = t
            }
        }
    })
});
game.module("engine.renderer.texture").body(function() {
    game.createClass("BaseTexture", {
        height: 0,
        loaded: !1,
        source: null,
        width: 0,
        _id: null,
        _loadCallback: null,
        staticInit: function(e, t) {
            this.source = e, this._loadCallback = t, e.getContext ? this._onload() : (e.onload = this._onload.bind(this), e.onerror = this._onerror.bind(this))
        },
        remove: function() {
            for (var e in game.BaseTexture.cache)
                if (game.BaseTexture.cache[e] === this) return void delete game.BaseTexture.cache[e]
        },
        _onerror: function() {
            if (!this._loadCallback) throw "Error loading image " + this._id;
            this._loadCallback("Error loading image " + this._id)
        },
        _onload: function() {
            this.loaded = !0, this.width = this.source.width / game.scale, this.height = this.source.height / game.scale, this._loadCallback && this._loadCallback()
        }
    }), game.addAttributes("BaseTexture", {
        cache: {},
        crossOrigin: "",
        clearCache: function() {
            for (var e in this.cache) delete this.cache[e]
        },
        fromAsset: function(e) {
            var t = game.paths[e],
                a = this.cache[t];
            return a || (a = this.fromImage(t)), a
        },
        fromCanvas: function(e) {
            e._id || (e._id = "canvas_" + this._id++);
            var t = this.cache[e._id];
            return t || ((t = new game.BaseTexture(e))._id = e._id, this.cache[e._id] = t), t
        },
        fromImage: function(e, t) {
            var a = this.cache[e];
            if (a) t && t();
            else {
                var i = document.createElement("img");
                this.crossOrigin && (i.crossOrigin = this.crossOrigin), i.src = e + game._nocache, (a = new game.BaseTexture(i, t))._id = e, this.cache[e] = a
            }
            return a
        },
        _id: 1
    }), game.createClass("Texture", {
        baseTexture: null,
        height: 0,
        position: null,
        width: 0,
        _anchor: null,
        _offset: null,
        _trim: null,
        staticInit: function(e, t, a, i, r) {
            this._anchor = new game.Vector, this._offset = new game.Vector, this._trim = new game.Vector, this.baseTexture = e instanceof game.BaseTexture ? e : game.BaseTexture.fromAsset(e), this.position = new game.Vector(t, a), this.width = i || this.baseTexture.width, this.height = r || this.baseTexture.height
        },
        remove: function() {
            for (var e in game.Texture.cache)
                if (game.Texture.cache[e] === this) return void delete game.Texture.cache[e]
        }
    }), game.addAttributes("Texture", {
        cache: {},
        clearCache: function() {
            for (var e in this.cache) delete this.cache[e]
        },
        fromAsset: function(e) {
            var t = game.paths[e] || e,
                a = this.cache[t];
            return a || (a = game.Texture.fromImage(t)), a
        },
        fromCanvas: function(e) {
            var t = this.cache[e._id];
            if (!t) {
                var a = game.BaseTexture.fromCanvas(e);
                t = new game.Texture(a), this.cache[e._id] = t
            }
            return t
        },
        fromImage: function(e) {
            var t = this.cache[e];
            return t || (t = new game.Texture(game.BaseTexture.fromImage(e)), this.cache[e] = t), t
        }
    })
});
game.module("engine.renderer.text").require("engine.renderer.sprite").body(function() {
    game.createClass("Font", {
        baseTexture: null,
        chars: {},
        letterSpacing: 0,
        lineHeight: 0,
        spaceWidth: 0,
        staticInit: function(t) {
            if (t.getElementsByTagName) var e = t.getElementsByTagName("page")[0].getAttribute("file"),
                s = (t.getElementsByTagName("info")[0], t.getElementsByTagName("common")[0]),
                a = t.getElementsByTagName("char");
            else e = t.pages[0].file, t.info, s = t.common, a = t.chars;
            this.baseTexture = game.BaseTexture.fromImage(game._getFilePath(e)), t.getElementsByTagName ? this.lineHeight = parseInt(s.getAttribute("lineHeight")) : this.lineHeight = parseInt(s.lineHeight);
            for (var i = 0; i < a.length; i++) {
                if (t.getElementsByTagName) var n = parseInt(a[i].getAttribute("xadvance")),
                    h = parseInt(a[i].getAttribute("id"));
                else n = parseInt(a[i].xadvance), h = parseInt(a[i].id);
                if (32 !== h) {
                    if (t.getElementsByTagName) var r = parseInt(a[i].getAttribute("xoffset")),
                        l = parseInt(a[i].getAttribute("yoffset")),
                        o = parseInt(a[i].getAttribute("x")) / game.scale,
                        g = parseInt(a[i].getAttribute("y")) / game.scale,
                        f = parseInt(a[i].getAttribute("width")) / game.scale,
                        c = parseInt(a[i].getAttribute("height")) / game.scale;
                    else r = parseInt(a[i].xoffset), l = parseInt(a[i].yoffset), o = parseInt(a[i].x) / game.scale, g = parseInt(a[i].y) / game.scale, f = parseInt(a[i].width) / game.scale, c = parseInt(a[i].height) / game.scale;
                    var d = new game.Texture(this.baseTexture, o, g, f, c);
                    this.chars[h] = {
                        texture: d,
                        xadvance: n,
                        xoffset: r,
                        yoffset: l
                    }
                } else this.spaceWidth = n
            }
        }
    }), game.addAttributes("Font", {
        cache: {},
        fromData: function(t) {
            if (t.getElementsByTagName) var e = t.getElementsByTagName("info")[0].getAttribute("face");
            else e = t.info.face;
            var s = game.Font.cache[e];
            return s || (s = new game.Font(t), game.Font.cache[e] = s, game.Text.defaultFont || (game.Text.defaultFont = e)), s
        },
        clearCache: function() {
            for (var t in this.cache) delete this.cache[t]
        }
    }), game.createClass("Text", "Container", {
        align: "left",
        font: null,
        fontClass: null,
        text: null,
        wrap: 0,
        _lines: null,
        staticInit: function(t, e) {
            this.super(), t = "string" == typeof t || "number" == typeof t ? t : "", this.text = this.text || t.toString(), game.merge(this, e), this.font = this.font || game.Text.defaultFont, this.font && this.setFont(this.font)
        },
        setFont: function(t) {
            if (this.font = t, this.fontClass = game.Font.cache[t], !this.fontClass) throw "Font " + t + " not found";
            return this.text && this.setText(this.text), this
        },
        setText: function(t) {
            return this.text = t.toString(), this.updateText(), this
        },
        updateText: function() {
            if (this.fontClass) {
                this.removeAll();
                for (var t = [{
                        words: [],
                        width: 0
                    }], e = 0, s = 0, a = "", i = 1, n = 0; n < this.text.length; n++) {
                    var h = this.text.charCodeAt(n);
                    if (32 === h || 10 === h) {
                        if (s > 0) t[e].width + s > this.wrap && this.wrap > 0 && t[e].words.length > 0 && (e++, t.push({
                            words: [],
                            width: 0
                        })), t[e].words.push({
                            width: s,
                            type: 1,
                            text: a,
                            num: i
                        }), t[e].width += s, a = "", i++
                    } else a += this.text[n];
                    if (32 !== h)
                        if (10 !== h) {
                            var r = this.fontClass.chars[h];
                            r && (s += r.xadvance + this.fontClass.letterSpacing)
                        } else e++, t.push({
                            words: [],
                            width: 0
                        }), s = 0;
                    else t[e].words.push({
                        width: this.fontClass.spaceWidth,
                        type: 0,
                        text: " ",
                        num: i
                    }), t[e].width += this.fontClass.spaceWidth, s = 0, i++
                }
                if (s > 0) t[e].width + s > this.wrap && this.wrap > 0 && t[e].words.length > 0 && (e++, t.push({
                    words: [],
                    width: 0
                })), t[e].words.push({
                    width: s,
                    type: 1,
                    text: a,
                    num: i
                }), t[e].width += s;
                var l = 0;
                for (n = 0; n < t.length; n++) {
                    var o = t[n];
                    o.width > l && (l = o.width);
                    for (var g = o.words.length - 1; g >= 0 && 0 === o.words[g].type; g--) o.width -= this.fontClass.spaceWidth
                }
                this._lines = t, this._generateText(l)
            }
        },
        _generateText: function(t) {
            var e = 0,
                s = 0,
                a = 0,
                i = 0;
            "center" === this.align && (e = t / 2 - this._lines[0].width / 2), "right" === this.align && (e = t - this._lines[0].width);
            for (var n = 0; n < this.text.length; n++) {
                this._lines[a].words[i] || (a++, this._lines[a] || a--, i = 0, e > 0 && (s += this.fontClass.lineHeight), e = 0, "center" === this.align && (e = t / 2 - this._lines[a].width / 2), "right" === this.align && (e = t - this._lines[a].width));
                var h = this.text.charCodeAt(n);
                32 === h && (e > 0 && (e += this.fontClass.spaceWidth, i++), i++), 10 === h && e > 0 && (s += this.fontClass.lineHeight, e = 0, i++);
                var r = this.fontClass.chars[h];
                if (r) {
                    var l = r.texture;
                    0 === n && (e -= r.xoffset);
                    var o = new game.Sprite(l);
                    o.position.x = (e + r.xoffset) / game.scale, o.position.y = (s + r.yoffset) / game.scale, this.addChild(o), e += r.xadvance + this.fontClass.letterSpacing
                }
            }
            this.updateTransform()
        }
    }), game.addAttributes("Text", {
        defaultFont: null
    }), game.createClass("SystemText", "Container", {
        align: "left",
        color: "#fff",
        font: "Arial",
        size: 14,
        text: "",
        staticInit: function(t, e) {
            this.super(e), this.text = t || this.text
        },
        _renderCanvas: function(t) {
            var e = this._worldTransform;
            t.globalAlpha = this._worldAlpha, t.setTransform(e.a, e.b, e.c, e.d, e.tx * game.scale, (e.ty + this.size) * game.scale), t.fillStyle = this.color, t.font = this.size * game.scale * game.scale + "px " + this.font, t.textAlign = this.align, t.fillText(this.text, 0, 0)
        }
    })
});
game.module("engine.renderer.spritesheet").body(function() {
    game.createClass("SpriteSheet", {
        frames: 0,
        height: 0,
        texture: null,
        textures: [],
        width: 0,
        staticInit: function(t, e, h) {
            this.width = this.width || e, this.height = this.height || h;
            var i = game.BaseTexture.cache[game.paths[this.texture || t]],
                s = Math.floor(i.width / this.width),
                r = Math.floor(i.height / this.height);
            this.frames = s * r;
            for (var a = 0; a < this.frames; a++) {
                var n = a % s * this.width,
                    u = Math.floor(a / s) * this.height,
                    f = new game.Texture(i, n, u, this.width, this.height);
                this.textures.push(f)
            }
        },
        frame: function(t) {
            return t = t.limit(0, this.frames - 1), new game.Sprite(this.textures[t])
        },
        anim: function(t, e, h) {
            e = e || 0;
            var i = [];
            if ((t = t || this.frames).length > 0)
                for (var s = 0; s < t.length; s++) i.push(this.textures[e + t[s]]);
            else
                for (s = 0; s < t; s++) i.push(this.textures[e + s]);
            return h ? i : new game.Animation(i)
        }
    })
});
game.module("engine.renderer.graphics").require("engine.renderer.container").body(function() {
    game.createClass("Graphics", "Container", {
        fillColor: "#fff",
        fillAlpha: 1,
        lineAlpha: 1,
        lineColor: "#fff",
        lineWidth: 0,
        blendMode: "source-over",
        shapes: [],
        beginFill: function(e, i) {
            return this.fillColor = e || this.fillColor, this.fillAlpha = i || this.fillAlpha, this
        },
        clear: function() {
            return this.shapes.length = 0, this
        },
        drawArc: function(e, i, a, l, t) {
            a *= game.scale;
            var h = new game.Arc(a, e, i, l, t);
            return this._drawShape(h), this
        },
        drawCircle: function(e, i, a) {
            a *= game.scale;
            var l = new game.Circle(a, e, i);
            return this._drawShape(l), this
        },
        drawRect: function(e, i, a, l) {
            l = l || a, a *= game.scale, l *= game.scale;
            var t = new game.Rectangle(a, l, e, i);
            return this._drawShape(t), this
        },
        lineStyle: function(e, i, a) {
            return this.lineWidth = e || this.lineWidth, this.lineColor = i || this.lineColor, this.lineAlpha = a || this.lineAlpha, this
        },
        lineTo: function(e, i) {},
        moveTo: function(e, i) {},
        _drawShape: function(e) {
            var i = new game.GraphicsShape(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, e);
            this.shapes.push(i)
        },
        _getBounds: function() {
            for (var e = this._worldTransform, i = e.a, a = e.b, l = e.c, t = e.d, h = e.tx, s = e.ty, r = 0, n = 0, o = 0; o < this.shapes.length; o++) {
                var d = this.shapes[o],
                    c = d.shape.x,
                    p = d.shape.y;
                d.shape.radius ? (c += d.shape.radius / game.scale, p += d.shape.radius / game.scale) : (c += d.shape.width / game.scale, p += d.shape.height / game.scale), r = Math.max(r, c), n = Math.max(n, p)
            }
            var f = i * r + h,
                g = a * r + s,
                u = i * r + l * n + h,
                m = t * n + a * r + s,
                A = l * n + h,
                w = t * n + s,
                C = Math.min(h, f, u, A),
                _ = Math.min(s, g, m, w);
            c = Math.max(h, f, u, A), p = Math.max(s, g, m, w);
            return this._worldBounds.x = C, this._worldBounds.y = _, this._worldBounds.width = c - C, this._worldBounds.height = p - _, this._worldBounds
        },
        _renderCanvas: function(e) {
            var i = this._worldTransform,
                a = i.tx * game.scale,
                l = i.ty * game.scale;
            e.globalCompositeOperation = this.blendMode, e.setTransform(i.a, i.b, i.c, i.d, a, l);
            for (var t = 0; t < this.shapes.length; t++) this.shapes[t]._render(e, this._worldAlpha)
        },
        _renderMask: function(e, i) {
            var a = i,
                l = a.tx * game.scale,
                t = a.ty * game.scale;
            e.save(), e.setTransform(a.a, a.b, a.c, a.d, l, t), e.beginPath();
            for (var h = 0; h < this.shapes.length; h++) this.shapes[h]._renderShape(e);
            e.closePath(), e.clip()
        }
    }), game.createClass("GraphicsShape", {
        fillAlpha: 1,
        fillColor: "",
        lineAlpha: 0,
        lineColor: "",
        lineWidth: 0,
        shape: null,
        staticInit: function(e, i, a, l, t, h) {
            this.lineWidth = e, this.lineColor = i, this.lineAlpha = a, this.fillColor = l, this.fillAlpha = t, this.shape = h
        },
        _render: function(e, i) {
            e.globalAlpha = this.fillAlpha * i, e.fillStyle = this.fillColor, e.strokeStyle = this.lineColor, e.lineWidth = this.lineWidth * game.scale, e.beginPath(), this._renderShape(e), this.fillColor && this.fillAlpha && e.fill(), this.lineWidth && (e.globalAlpha = this.lineAlpha * i, e.stroke())
        },
        _renderShape: function(e) {
            var i = this.shape,
                a = i.x * game.scale,
                l = i.y * game.scale;
            i.width ? e.rect(a, l, i.width, i.height) : i.radius && ("number" == typeof i.startAngle && "number" == typeof i.endAngle ? (e.arc(a, l, i.radius, i.startAngle, i.endAngle), e.closePath()) : e.arc(a, l, i.radius, 0, 2 * Math.PI))
        }
    })
});
game.module("engine.renderer.animation").require("engine.renderer.sprite").body(function() {
    game.createClass("Animation", "Sprite", {
        anims: {},
        currentAnim: null,
        currentFrame: 0,
        loop: !0,
        onComplete: null,
        playing: !1,
        random: !1,
        reverse: !1,
        speed: 10,
        textures: null,
        _frameTime: 0,
        staticInit: function(e) {
            if (this.currentAnim = this, this.textures = this.textures || e, "string" == typeof this.textures && -1 !== this.textures.indexOf("atlas")) {
                var t = game.getJSON(this.textures);
                for (var r in this.textures = [], t.frames) this.textures.push(r)
            }
            for (var i = [], s = 0; s < this.textures.length; s++) {
                var n = this.textures[s];
                !n instanceof game.Texture && (n = game.Texture.fromAsset(n)), i.push(n)
            }
            this.textures = i, this.super(this.textures[0])
        },
        addAnim: function(e, t, r, i) {
            if (e && void 0 !== typeof t) {
                "object" == typeof r && (i = r);
                var s = [];
                if (t.length)
                    for (var n = 0; n < t.length; n++) s[n] = this.textures[t[n]];
                else if ("number" == typeof t && "number" == typeof r)
                    for (n = 0; n < r; n++) s[n] = this.textures[t + n];
                var u = new game.Animation(s);
                return u.loop = this.loop, u.random = this.random, u.reverse = this.reverse, u.speed = this.speed, game.merge(u, i), this.anims[e] = u, this
            }
        },
        gotoFrame: function(e) {
            if (!this.currentAnim.textures) throw "No textures found for animation";
            if (this.currentAnim.textures[e]) return this.currentFrame = e, this._frameTime = 0, this.setTexture(this.currentAnim.textures[e]), this
        },
        play: function(e, t) {
            return this.playing = !0, this.currentAnim = this.anims[e] || this, "number" == typeof e && (t = e), "number" != typeof t && this.reverse && (t = this.textures.length - 1), this.gotoFrame(t || 0), this
        },
        stop: function(e) {
            return this.playing = !1, "number" == typeof e && this.gotoFrame(e), this
        },
        updateTransform: function() {
            this.playing && this._updateAnimation(), this.super()
        },
        _updateAnimation: function() {
            var e = this.currentAnim;
            if (!e.textures) throw "No textures found for animation";
            if (this._frameTime += e.speed * game.delta, this._frameTime >= 1) {
                if (this._frameTime = 0, e.random && e.textures.length > 1) {
                    for (var t = this.currentFrame; t === this.currentFrame;) t = Math.round(Math.random(0, e.textures.length - 1));
                    return this.currentFrame = t, void this.setTexture(e.textures[t])
                }(t = this.currentFrame + (e.reverse ? -1 : 1)) >= e.textures.length ? e.loop ? (this.currentFrame = 0, this.setTexture(e.textures[0])) : (this.playing = !1, e.onComplete && e.onComplete()) : t < 0 ? e.loop ? (this.currentFrame = e.textures.length - 1, this.setTexture(e.textures.last())) : (this.playing = !1, e.onComplete && e.onComplete()) : (this.currentFrame = t, this.setTexture(e.textures[t]))
            }
        }
    }), game.addAttributes("Animation", {
        fromTextures: function(e) {
            var t = [];
            for (var r in game.Texture.cache) - 1 !== r.indexOf(e) && t.push(r);
            if (0 === t.length)
                for (var r in game.BaseTexture.cache) - 1 !== r.indexOf(e) && t.push(r);
            if (t.length > 0) return t.sort(game.compare), new game.Animation(t)
        }
    })
});
game.module("engine.renderer.core").require("engine.renderer.animation", "engine.renderer.container", "engine.renderer.fastcontainer", "engine.renderer.graphics", "engine.renderer.sprite", "engine.renderer.spritesheet", "engine.renderer.text", "engine.renderer.texture", "engine.renderer.tilingsprite").body(function() {
    game.createClass("Renderer", {
        canvas: null,
        context: null,
        _smoothProperty: null,
        init: function(e, t) {
            game.device.cocoonCanvasPlus || (this.canvas = document.getElementById(game.System.canvasId)), this.canvas || (this.canvas = document.createElement("canvas"), this.canvas.id = game.System.canvasId, this.canvas.style.display = "block", this.canvas.style.outline = "none", "nearest" === game.Renderer.scaleMode && (this.canvas.style.imageRendering = "pixelated"), this.canvas.tabIndex = 1, document.body.appendChild(this.canvas), game.System.center || (document.body.style.margin = 0)), game._normalizeVendorAttribute(this.canvas, "requestFullScreen"), this._initContext(), "imageSmoothingEnabled" in this.context ? this._smoothProperty = "imageSmoothingEnabled" : "webkitImageSmoothingEnabled" in this.context ? this._smoothProperty = "webkitImageSmoothingEnabled" : "mozImageSmoothingEnabled" in this.context ? this._smoothProperty = "mozImageSmoothingEnabled" : "oImageSmoothingEnabled" in this.context ? this._smoothProperty = "oImageSmoothingEnabled" : "msImageSmoothingEnabled" in this.context && (this._smoothProperty = "msImageSmoothingEnabled"), this._resize(e, t)
        },
        _clear: function() {
            game.scene.backgroundColor ? (this.context.fillStyle = game.scene.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)) : this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
        },
        _hide: function() {
            this.canvas.style.display = "none"
        },
        _initContext: function() {
            this.context = this.canvas.getContext("2d")
        },
        _position: function(e, t) {
            this.canvas.style.position = "absolute", this.canvas.style.left = e + "px", this.canvas.style.top = t + "px"
        },
        _render: function(e) {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.context.globalCompositeOperation = "source-over", game.Renderer.clearBeforeRender && this._clear(), e._updateChildTransform(), e._render(this.context)
        },
        _resize: function(e, t) {
            this.canvas.width = e, this.canvas.height = t, this._smoothProperty && (this.context[this._smoothProperty] = "linear" === game.Renderer.scaleMode)
        },
        _show: function() {
            this.canvas.style.display = "block"
        },
        _size: function(e, t) {
            this.canvas.style.width = e + "px", this.canvas.style.height = t + "px"
        }
    }), game.addAttributes("Renderer", {
        clearBeforeRender: !0,
        roundPixels: !1,
        scaleMode: "linear"
    }), game.createClass("Matrix", {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0,
        reset: function() {
            var e = this.constructor.prototype;
            return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this
        }
    })
});
game.module("engine.pool").body(function() {
    game.createClass("Pool", {
        pools: {},
        create: function(o) {
            return !this.pools[o] && (this.pools[o] = [], !0)
        },
        get: function(o) {
            if (this.pools[o] && this.pools[o].length) return this.pools[o].pop()
        },
        put: function(o, t) {
            return !!this.pools[o] && (this.pools[o].push(t), !0)
        }
    })
});
game.module("engine.physics").require("engine.renderer.sprite").body(function() {
    game.createClass("Body", {
        collideAgainst: [],
        damping: 0,
        force: null,
        last: null,
        mass: 1,
        position: null,
        shape: null,
        static: !1,
        velocity: null,
        velocityLimit: null,
        world: null,
        _collides: [],
        _collisionGroup: 0,
        init: function(i) {
            this.force = new game.Vector, this.position = new game.Vector, this.velocity = new game.Vector, this.velocityLimit = new game.Vector(980, 980), this.last = new game.Vector, game.merge(this, i)
        },
        addShape: function(i) {
            return this.shape = i, this
        },
        addTo: function(i) {
            if (!this.world) return i.addBody(this), this
        },
        afterCollide: function() {},
        applyImpulse: function(i, t) {
            return this.velocity.add(i, t), this
        },
        collide: function() {
            return !0
        },
        remove: function() {
            return this.world && this.world.removeBody(this), this
        },
        removeCollision: function() {
            return this.world && this.world._removeBodyCollision(this), this
        },
        _update: function() {
            if (this.last.copy(this.position), !this.static) {
                if (this.velocity.x += this.world.gravity.x * this.mass * game.delta, this.velocity.y += this.world.gravity.y * this.mass * game.delta, this.velocity.x += this.force.x * game.delta, this.velocity.y += this.force.y * game.delta, this.damping > 0 && this.damping < 1) {
                    var i = Math.pow(1 - this.damping, game.delta);
                    this.velocity.x *= i, this.velocity.y *= i
                }
                this.velocityLimit.x > 0 && (this.velocity.x > this.velocityLimit.x && (this.velocity.x = this.velocityLimit.x), this.velocity.x < -this.velocityLimit.x && (this.velocity.x = -this.velocityLimit.x)), this.velocityLimit.y > 0 && (this.velocity.y > this.velocityLimit.y && (this.velocity.y = this.velocityLimit.y), this.velocity.y < -this.velocityLimit.y && (this.velocity.y = -this.velocityLimit.y)), this.position.x += this.velocity.x * game.delta, this.position.y += this.velocity.y * game.delta
            }
        }
    }), game.defineProperties("Body", {
        collisionGroup: {
            get: function() {
                return this._collisionGroup
            },
            set: function(i) {
                this._collisionGroup !== i && (this.world && "number" == typeof this._collisionGroup && this.world._removeBodyCollision(this), this._collisionGroup = i, this.world && this.world._addBodyCollision(this))
            }
        }
    }), game.createClass("Physics", {
        bodies: [],
        gravity: null,
        _collisionGroups: {},
        staticInit: function(i, t) {
            i = "number" == typeof i ? i : 0, t = "number" == typeof t ? t : 980, this.gravity = new game.Vector(i, t)
        },
        addBody: function(i) {
            i.world = this, i._remove = !1, this.bodies.push(i), this._addBodyCollision(i)
        },
        hitResponse: function(i, t) {
            if (i.static) return !1;
            if (i.shape.width && t.shape.width) {
                if (i.last.y + i.shape.height / 2 <= t.last.y - t.shape.height / 2) {
                    if (i.collide(t, "DOWN")) return i.position.y = t.position.y - t.shape.height / 2 - i.shape.height / 2, !0
                } else if (i.last.y - i.shape.height / 2 >= t.last.y + t.shape.height / 2) {
                    if (i.collide(t, "UP")) return i.position.y = t.position.y + t.shape.height / 2 + i.shape.height / 2, !0
                } else if (i.last.x + i.shape.width / 2 <= t.last.x - t.shape.width / 2) {
                    if (i.collide(t, "RIGHT")) return i.position.x = t.position.x - t.shape.width / 2 - i.shape.width / 2, !0
                } else if (i.last.x - i.shape.width / 2 >= t.last.x + t.shape.width / 2) {
                    if (i.collide(t, "LEFT")) return i.position.x = t.position.x + t.shape.width / 2 + i.shape.width / 2, !0
                } else if (i.collide(t)) return !0
            } else if (i.shape.radius && t.shape.radius) {
                var o = t.position.angle(i.position);
                if (i.collide(t, o)) {
                    var s = i.shape.radius + t.shape.radius;
                    return i.position.x = t.position.x + Math.cos(o) * s, i.position.y = t.position.y + Math.sin(o) * s, !0
                }
            } else if (i.collide(t)) return !0;
            return !1
        },
        hitTest: function(i, t) {
            if (i.shape.width && t.shape.width) return !(i.position.y + i.shape.height / 2 <= t.position.y - t.shape.height / 2 || i.position.y - i.shape.height / 2 >= t.position.y + t.shape.height / 2 || i.position.x - i.shape.width / 2 >= t.position.x + t.shape.width / 2 || i.position.x + i.shape.width / 2 <= t.position.x - t.shape.width / 2);
            if (i.shape.radius && t.shape.radius) return i.shape.radius + t.shape.radius > i.position.distance(t.position);
            if (i.shape.width && t.shape.radius || i.shape.radius && t.shape.width) {
                var o = i.shape.width ? i : t,
                    s = i.shape.radius ? i : t,
                    e = Math.max(o.position.x - o.shape.width / 2, Math.min(o.position.x + o.shape.width / 2, s.position.x)),
                    h = Math.max(o.position.y - o.shape.height / 2, Math.min(o.position.y + o.shape.height / 2, s.position.y));
                return Math.pow(s.position.x - e, 2) + Math.pow(s.position.y - h, 2) < s.shape.radius * s.shape.radius
            }
            return !1
        },
        removeBody: function(i) {
            i.world && (i.world = null, i._remove = !0)
        },
        _addBodyCollision: function(i) {
            "number" == typeof i.collisionGroup && (this._collisionGroups[i.collisionGroup] = this._collisionGroups[i.collisionGroup] || [], -1 === this._collisionGroups[i.collisionGroup].indexOf(i) && this._collisionGroups[i.collisionGroup].push(i))
        },
        _collide: function(i) {
            var t, o, s, e;
            for (t = 0; t < i.collideAgainst.length; t++)
                if (i._collides.length = 0, e = this._collisionGroups[i.collideAgainst[t]]) {
                    for (o = e.length - 1; o >= 0 && e; o--) i !== (s = e[o]) && this.hitTest(i, s) && i._collides.push(s);
                    for (o = i._collides.length - 1; o >= 0; o--) this.hitResponse(i, i._collides[o]) && i.afterCollide(i._collides[o])
                }
        },
        _removeBodyCollision: function(i) {
            "number" == typeof i.collisionGroup && this._collisionGroups[i.collisionGroup] && -1 !== this._collisionGroups[i.collisionGroup].indexOf(i) && this._collisionGroups[i.collisionGroup].erase(i)
        },
        _update: function() {
            var i;
            for (i = this.bodies.length - 1; i >= 0; i--) this.bodies[i]._remove ? (this._removeBodyCollision(this.bodies[i]), this.bodies.splice(i, 1)) : this.bodies[i]._update()
        },
        _updateCollision: function() {
            for (i in this._collisionGroups)
                if (0 !== this._collisionGroups[i].length)
                    for (j = 0; j < this._collisionGroups[i].length; j++) this._collisionGroups[i][j] && this._collisionGroups[i][j].collideAgainst.length > 0 && this._collide(this._collisionGroups[i][j]);
                else delete this._collisionGroups[i]
        }
    }), game.createClass("PhysicsSprite", "Sprite", {
        body: null,
        shape: "Rectangle",
        staticInit: function(i, t, o) {
            this.super(i), this.anchorCenter(), t = t || this.width, o = o || this.height;
            var s = new game[this.shape](t, o);
            this.body = new game.Body, this.body.addShape(s), this.body.collide = this.collide.bind(this), this.position = this.body.position
        },
        addTo: function(i, t) {
            if (!(t = t || game.scene.world)) throw "Physics world not found";
            return this.body.addTo(t), this.super(i)
        },
        collide: function() {
            return !0
        },
        remove: function() {
            return this.body.remove(), this.super()
        }
    })
});
game.module("engine.renderer.fastcontainer").require("engine.renderer.container").body(function() {
    game.createClass("FastContainer", "Container", {
        _isRotated: !0,
        _getBounds: function() {
            return this._worldBounds.x = 0, this._worldBounds.y = 0, this._worldBounds.width = 0, this._worldBounds.height = 0, this._worldBounds
        },
        _renderBatch: function(e, a) {
            a.globalAlpha = this._worldAlpha * e.alpha;
            var t = this._worldTransform,
                r = e.texture;
            e._cachedSprite && (r = e._cachedSprite.texture);
            var i = r.position.x * game.scale,
                s = r.position.y * game.scale,
                n = r.width * game.scale,
                o = r.height * game.scale;
            if (e.rotation % (2 * Math.PI) == 0) {
                this._isRotated && (a.setTransform(t.a, t.b, t.c, t.d, t.tx * game.scale, t.ty * game.scale), this._isRotated = !1);
                var d = (e.position.x - e.anchor.x * e.scale.x) * game.scale,
                    l = (e.position.y - e.anchor.y * e.scale.y) * game.scale;
                a.drawImage(r.baseTexture.source, i, s, n, o, d, l, n * e.scale.x, o * e.scale.y)
            } else {
                this._isRotated = !0, e.updateTransform();
                var h = e._worldTransform;
                d = h.tx * game.scale, l = h.ty * game.scale;
                game.Renderer.roundPixels && (d |= 0, l |= 0), a.setTransform(h.a, h.b, h.c, h.d, d, l), a.drawImage(r.baseTexture.source, i, s, n, o, 0, 0, n, o)
            }
        },
        _renderChildren: function(e) {
            this._isRotated = !0;
            for (var a = 0; a < this.children.length; a++) {
                var t = this.children[a],
                    r = t.texture || t._cachedSprite;
                t.visible && !(t.alpha <= 0) && t.renderable && r && this._renderBatch(t, e)
            }
        },
        _updateChildTransform: function() {
            for (var e = this.children.length - 1; e >= 0; e--) {
                var a = this.children[e];
                !a.visible || a.alpha <= 0 || a.updateAnimation && a.updateAnimation()
            }
        }
    })
});
game.module("engine.renderer.container").require("engine.geometry").body(function() {
    game.createClass("Container", {
        alpha: 1,
        anchor: null,
        buttonMode: !1,
        children: [],
        hitArea: null,
        mask: null,
        position: null,
        renderable: !0,
        rotation: 0,
        scale: null,
        skew: null,
        stage: null,
        visible: !0,
        _cached: !1,
        _cachedSprite: null,
        _cosCache: 1,
        _interactive: !1,
        _lastTransformUpdate: -1,
        _localTransform: null,
        _parent: null,
        _rotationCache: 0,
        _sinCache: 0,
        _worldAlpha: 1,
        _worldBounds: null,
        _worldTransform: null,
        staticInit: function(t) {
            this.anchor = new game.Vector, this.position = new game.Vector, this.scale = new game.Vector(1), this.skew = new game.Vector, this._worldBounds = new game.Rectangle, this._worldTransform = new game.Matrix, this._localTransform = new game.Matrix, game.merge(this, t)
        },
        addChild: function(t) {
            return t.parent = this, this
        },
        addTo: function(t) {
            return this.parent = t, this
        },
        anchorCenter: function() {
            return this.anchor.set(this.width / 2, this.height / 2), this
        },
        center: function(t, e, i, s) {
            if (t || (t = this.parent), t) {
                if (t === game.scene.stage) var r = game.width / 2,
                    h = game.height / 2;
                else {
                    var n = t._getBounds();
                    r = n.width / 2, h = n.height / 2;
                    s && (r += n.x, h += n.y)
                }
                var a = this._getBounds();
                return r += this.anchor.x * this.scale.x, h += this.anchor.y * this.scale.y, r -= a.width * this.scale.x / 2, h -= a.height * this.scale.y / 2, e = e || 0, i = i || 0, this.position.set(r + e, h + i), this
            }
        },
        click: function() {},
        hitTest: function(t) {
            if (!t) return !1;
            var e = this._getBounds(),
                i = t._getBounds();
            return !(e.y + e.height / 2 <= i.y - i.height / 2 || e.y - e.height / 2 >= i.y + i.height / 2 || e.x - e.width / 2 >= i.x + i.width / 2 || e.x + e.width / 2 <= i.x - i.width / 2)
        },
        mousedown: function() {},
        mousemove: function() {},
        mouseout: function() {},
        mouseover: function() {},
        mouseup: function() {},
        mouseupoutside: function() {},
        remove: function() {
            return this.parent && this.parent.removeChild(this), this
        },
        removeAll: function() {
            for (var t = this.children.length - 1; t >= 0; t--) this.children[t].remove();
            return this
        },
        removeChild: function(t) {
            var e = this.children.indexOf(t);
            if (-1 !== e) return this.children.splice(e, 1), t._parent = null, this.stage && t._removeStageReference(), this._cached && (this._destroyCachedSprite(), this._generateCachedSprite()), this
        },
        swap: function(t) {
            if (this.parent) return this.parent.swapChildren(this, t), this
        },
        swapChildren: function(t, e) {
            if (t !== e) {
                var i = this.children.indexOf(t),
                    s = this.children.indexOf(e);
                i < 0 || s < 0 || (this.children[i] = e, this.children[s] = t)
            }
        },
        updateTransform: function() {
            if (!this.parent) return this._updateChildTransform();
            var t = this.parent._worldTransform,
                e = this._localTransform,
                i = this._worldTransform;
            this._rotationCache !== this.rotation && (this._rotationCache = this.rotation, this._sinCache = Math.sin(this.rotation), this._cosCache = Math.cos(this.rotation));
            var s = this.anchor.x,
                r = this.anchor.y;
            e.a = this._cosCache * this.scale.x, e.b = this._sinCache * this.scale.x, e.c = -this._sinCache * this.scale.y, e.d = this._cosCache * this.scale.y, e.tx = this.position.x - (s * e.a + r * e.c), e.ty = this.position.y - (s * e.b + r * e.d), i.a = e.a * t.a + e.b * t.c, i.b = e.a * t.b + e.b * t.d, i.c = e.c * t.a + e.d * t.c, i.d = e.c * t.b + e.d * t.d, i.tx = e.tx * t.a + e.ty * t.c + t.tx, i.ty = e.tx * t.b + e.ty * t.d + t.ty, i.c += this.skew.x * i.a, i.d += this.skew.x * i.b, i.a += this.skew.y * i.c, i.b += this.skew.y * i.d, this._worldAlpha = this.parent._worldAlpha * this.alpha, this._lastTransformUpdate = game.Timer.time, this._cachedSprite ? this._cachedSprite._worldAlpha = this._worldAlpha : this._updateChildTransform()
        },
        _destroyCachedSprite: function() {
            this._cachedSprite && this._cachedSprite.texture.remove(), this._cachedSprite = null
        },
        _generateCachedSprite: function() {
            this.updateTransform();
            var t = document.createElement("canvas"),
                e = t.getContext("2d"),
                i = this._getBounds();
            t.width = i.width / this.scale.x * game.scale, t.height = i.height / this.scale.y * game.scale, this._worldTransform.reset(), this._updateChildTransform(), this._renderCanvas(e), this._renderChildren(e);
            var s = game.Texture.fromCanvas(t),
                r = new game.Sprite(s);
            r._parent = this, this._cachedSprite = r
        },
        _getBounds: function() {
            if (!this.children.length) return this._worldBounds.x = this._worldTransform.tx, this._worldBounds.y = this._worldTransform.ty, this._worldBounds.width = 0, this._worldBounds.height = 0, this._worldBounds;
            if (this._cachedSprite) {
                if (this.rotation) {
                    var t = this._cachedSprite.texture.width,
                        e = this._cachedSprite.texture.height,
                        i = this._worldTransform,
                        s = i.a,
                        r = i.b,
                        h = i.c,
                        n = i.d,
                        a = i.tx,
                        o = i.ty,
                        d = s * t + a,
                        c = r * t + o,
                        l = s * t + h * e + a,
                        u = n * e + r * t + o,
                        _ = h * e + a,
                        f = n * e + o,
                        m = Math.min(a, d, l, _),
                        g = Math.min(o, c, u, f),
                        p = Math.max(a, d, l, _),
                        w = Math.max(o, c, u, f);
                    return this._worldBounds.x = m, this._worldBounds.y = g, this._worldBounds.width = p - m, this._worldBounds.height = w - g, this._worldBounds
                }
                return this._worldBounds.x = this._worldTransform.tx + this._cachedSprite.position.x, this._worldBounds.y = this._worldTransform.ty + this._cachedSprite.position.y, this._worldBounds.width = this._cachedSprite.texture.width * this._worldTransform.a, this._worldBounds.height = this._cachedSprite.texture.height * this._worldTransform.d, this._worldBounds
            }
            this._lastTransformUpdate < game.Timer._lastFrameTime && this.updateTransform();
            m = this._worldTransform.tx, g = this._worldTransform.ty, p = this._worldTransform.tx, w = this._worldTransform.ty;
            if (this.mask) {
                var x = this.mask._getBounds();
                m = x.x, g = x.y, p = m + x.width, w = g + x.height
            } else
                for (var v = 0; v < this.children.length; v++) {
                    var y = this.children[v],
                        T = y._getBounds(y._localTransform),
                        C = this._worldTransform.tx + T.x,
                        B = this._worldTransform.ty + T.y,
                        S = C + T.width,
                        b = B + T.height;
                    C < m && (m = C), B < g && (g = B), S > p && (p = S), b > w && (w = b)
                }
            return this._worldBounds.x = m, this._worldBounds.y = g, this._worldBounds.width = (p - m) * Math.abs(this.scale.x), this._worldBounds.height = (w - g) * Math.abs(this.scale.y), this._worldBounds
        },
        _removeStageReference: function() {
            for (var t = 0; t < this.children.length; t++) {
                this.children[t]._removeStageReference()
            }
            this._interactive && (game.input._needUpdate = !0), this.stage = null
        },
        _render: function(t) {
            this.mask && this.mask._renderMask && this.mask._renderMask(t, this._worldTransform), this._cachedSprite ? this._cachedSprite._renderCanvas(t, this._worldTransform) : (this._renderCanvas(t), this._renderChildren(t)), this.mask && this.mask._renderMask && t.restore()
        },
        _renderCanvas: function(t) {},
        _renderChildren: function(t) {
            for (var e = 0; e < this.children.length; e++) {
                var i = this.children[e];
                !i.visible || i.alpha <= 0 || !i.renderable || i._render(t)
            }
        },
        _setStageReference: function(t) {
            this.stage = t, this._interactive && (game.input._needUpdate = !0);
            for (var e = 0; e < this.children.length; e++) {
                this.children[e]._setStageReference(t)
            }
        },
        _updateChildTransform: function() {
            for (var t = this.children.length - 1; t >= 0; t--) {
                var e = this.children[t];
                e.visible && e.updateTransform()
            }
        },
        _updateParentTransform: function() {
            this.parent ? this.parent._updateParentTransform() : this.updateTransform()
        }
    }), game.defineProperties("Container", {
        cache: {
            get: function() {
                return this._cached
            },
            set: function(t) {
                this._cached !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cached = t)
            }
        },
        height: {
            get: function() {
                return this._getBounds().height
            },
            set: function(t) {
                this.scale.y = t / this.height
            }
        },
        interactive: {
            get: function() {
                return this._interactive
            },
            set: function(t) {
                this._interactive !== t && (this._interactive = t, this.stage && (game.input._needUpdate = !0))
            }
        },
        parent: {
            get: function() {
                return this._parent
            },
            set: function(t) {
                -1 === t.children.indexOf(this) && (this.parent && this.remove(), t.children.push(this), this._parent = t, t.stage && this._setStageReference(t.stage), t._cached && (t._destroyCachedSprite(), t._generateCachedSprite()))
            }
        },
        width: {
            get: function() {
                return this._getBounds().width
            },
            set: function(t) {
                this.scale.x = t / this.width
            }
        },
        x: {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        },
        y: {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        }
    })
});
game.module("engine.renderer.sprite").require("engine.renderer.container").body(function() {
    game.createClass("Sprite", "Container", {
        blendMode: "source-over",
        texture: null,
        tint: null,
        tintAlpha: 1,
        staticInit: function(t, e) {
            this.super(e), this.setTexture(this.texture || t)
        },
        setTexture: function(t) {
            this.texture = t instanceof game.Texture ? t : game.Texture.fromAsset(t)
        },
        _destroyTintedTexture: function() {
            this._tintedTexture && this._tintedTexture.remove(), this._tintedTexture = null, this._tintedTextureGenerated = !1
        },
        _generateTintedTexture: function(t, e) {
            var i = document.createElement("canvas"),
                r = i.getContext("2d"),
                h = this._getBounds();
            i.width = h.width / this.scale.x * game.scale, i.height = h.height / this.scale.y * game.scale, r.fillStyle = t.substr(0, 7), r.globalAlpha = e || 1, r.fillRect(0, 0, i.width, i.height), r.globalAlpha = 1;
            var s = this.blendMode;
            return this.blendMode = "destination-atop", this._renderCanvas(r, new game.Matrix), this.blendMode = s, game.Texture.fromCanvas(i)
        },
        _getBounds: function(t) {
            if (this._cachedSprite) return this._worldBounds.x = this._worldTransform.tx + this._cachedSprite.position.x, this._worldBounds.y = this._worldTransform.ty + this._cachedSprite.position.y, this._worldBounds.width = this._cachedSprite.texture.width * this._worldTransform.a, this._worldBounds.height = this._cachedSprite.texture.height * this._worldTransform.d, this._worldBounds;
            for (var e = this.texture.width, i = this.texture.height, r = t || this._worldTransform, h = r.a, s = r.b, n = r.c, a = r.d, d = r.tx, o = r.ty, u = h * e + d, l = s * e + o, x = h * e + n * i + d, c = a * i + s * e + o, g = n * i + d, _ = a * i + o, m = Math.min(d, u, x, g), w = Math.min(o, l, c, _), T = Math.max(d, u, x, g), f = Math.max(o, l, c, _), p = 0; p < this.children.length; p++)
                if (this.children[p].visible && !(this.children[p].alpha <= 0)) {
                    var b = this.children[p]._getBounds(),
                        y = b.x,
                        M = y + b.width,
                        v = b.y,
                        B = v + b.height;
                    m = Math.min(m, y), w = Math.min(w, v), T = Math.max(T, M), f = Math.max(f, B)
                }
            return this._worldBounds.x = m, this._worldBounds.y = w, this._worldBounds.width = T - m, this._worldBounds.height = f - w, this._worldBounds
        },
        _renderCanvas: function(t, e, i, r) {
            if (!this.texture) return !0;
            if (!this.texture.baseTexture.loaded) return !0;
            if (!this.texture.width && this.texture.baseTexture.width && (this.texture.width = this.texture.baseTexture.width), !this.texture.height && this.texture.baseTexture.height && (this.texture.height = this.texture.baseTexture.height), !this.texture.width || !this.texture.height) return !0;
            !this.tint || this._tintedTexture || this._tintedTextureGenerated ? !this.tint && this._tintedTexture && this._destroyTintedTexture() : (this._tintedTextureGenerated = !0, this._tintedTexture = this._generateTintedTexture(this.tint, this.tintAlpha)), t.globalCompositeOperation = this.blendMode, t.globalAlpha = this._worldAlpha;
            var h = this._tintedTexture || this.texture,
                s = e || this._worldTransform,
                n = s.tx,
                a = s.ty;
            game.Renderer.roundPixels && (n |= 0, a |= 0), n *= game.scale, a *= game.scale;
            var d = h.position.x * game.scale,
                o = h.position.y * game.scale,
                u = h.width * game.scale,
                l = h.height * game.scale;
            i && (d = i.x, o = i.y, u = i.width, l = i.height), r && (n += r.x, a += r.y), t.setTransform(s.a, s.b, s.c, s.d, n, a), h._trim.x && (u = h._trim.x), h._trim.y && (l = h._trim.y);
            var x = h._offset.x - h._anchor.x,
                c = h._offset.y - h._anchor.y;
            t.drawImage(h.baseTexture.source, d, o, u, l, x, c, u, l)
        }
    }), game.defineProperties("Sprite", {
        width: {
            get: function() {
                return Math.abs(this.scale.x) * this.texture.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.width
            }
        },
        height: {
            get: function() {
                return Math.abs(this.scale.y) * this.texture.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.height
            }
        }
    })
});
game.module("engine.particle").require("engine.renderer.sprite", "engine.renderer.fastcontainer").body(function() {
    game.createClass("Particles", "FastContainer", {
        accelAngle: Math.PI / 2,
        accelAngleVar: 0,
        accelSpeed: 0,
        accelSpeedVar: 0,
        active: !0,
        alphaEnd: 0,
        alphaStart: 1,
        angle: 0,
        angleVar: Math.PI,
        emitCount: 1,
        emitDuration: 0,
        emitRate: 100,
        life: 2e3,
        lifeVar: 0,
        onComplete: null,
        particles: [],
        startPos: null,
        startPosVar: null,
        startRot: 0,
        startRotVar: 0,
        randomTexture: !0,
        rotate: 0,
        rotateVar: 0,
        scaleEnd: 1,
        scaleEndVar: 0,
        scaleStart: 1,
        scaleStartVar: 0,
        speed: 100,
        speedVar: 0,
        target: null,
        targetForce: 0,
        targetUpdate: !0,
        textures: [],
        velocityLimit: null,
        velRotate: 0,
        velRotateVar: 0,
        _currentTexture: 0,
        _durationTimer: 0,
        _onCompleteCalled: !1,
        _poolName: null,
        _rateTimer: 0,
        staticInit: function(t, e) {
            this.super(), t && ("string" == typeof t ? this.textures.push(t) : this.textures = t), this._poolName = game.Particles.poolName, this.startPos = new game.Vector, this.startPosVar = new game.Vector, this.target = new game.Vector, this.velocityLimit = new game.Vector, game.pool.create(this._poolName), game.merge(this, e)
        },
        emit: function(t) {
            t = t || this.emitCount;
            for (var e = 0; e < t; e++) this._addParticle()
        },
        remove: function() {
            this.super(), this._remove = !0
        },
        reset: function() {
            this._rateTimer = 0, this._durationTimer = 0, this.active = !0, this._onCompleteCalled = !1
        },
        updateTransform: function() {
            if (this._remove)
                for (var t = this.children.length - 1; t >= 0; t--) this._removeParticle(this.children[t]);
            else {
                this._durationTimer += 1e3 * game.delta, this.emitDuration > 0 && (this.active = this._durationTimer < this.emitDuration, this.active || 0 !== this.children.length || "function" != typeof this.onComplete || this._onCompleteCalled || (this.onComplete(), this._onCompleteCalled = !0)), this.emitRate && this.active && (this._rateTimer += 1e3 * game.delta, this._rateTimer >= 0 && (this._rateTimer = -this.emitRate, this.emit()));
                for (t = this.children.length - 1; t >= 0; t--) this.children[t]._update();
                this.super()
            }
        },
        _addParticle: function() {
            if (this.randomTexture) var t = this.textures.random();
            else {
                t = this.textures[this._currentTexture];
                this._currentTexture++, this._currentTexture >= this.textures.length && (this._currentTexture = 0)
            }
            if (t) {
                var e = game.pool.get(this._poolName);
                e ? e.setTexture(t) : e = new game.Particle(t), e.emitter = this, e.rotation = this.startRot + this._getVar(this.startRotVar), e.alpha = this.alphaStart, e.position.x = this.startPos.x + this._getVar(this.startPosVar.x), e.position.y = this.startPos.y + this._getVar(this.startPosVar.y);
                var i = this._getVar(this.angleVar),
                    a = this.angle + i,
                    s = this.speed + this._getVar(this.speedVar);
                e.velocity.x = Math.cos(a) * s, e.velocity.y = Math.sin(a) * s, this.angleVar !== this.accelAngleVar && (i = this._getVar(this.accelAngleVar)), a = this.accelAngle + i, s = this.accelSpeed + this._getVar(this.accelSpeedVar), e.accel.x = Math.cos(a) * s, e.accel.y = Math.sin(a) * s, e.life = this.life + this._getVar(this.lifeVar), e.rotateAmount = this.rotate + this._getVar(this.rotateVar), e.velRotate = this.velRotate + this._getVar(this.velRotateVar), this.alphaStart !== this.alphaEnd ? (e.deltaAlpha = this.alphaEnd - this.alphaStart, e.deltaAlpha /= e.life / 1e3) : e.deltaAlpha = 0;
                var r = this.scaleStart + this._getVar(this.scaleStartVar);
                this.scaleStart !== this.scaleEnd ? (e.deltaScale = this.scaleEnd + this._getVar(this.scaleEndVar) - r, e.deltaScale /= e.life / 1e3) : e.deltaScale = 0, e.scale.set(r), e.anchor.x = e.texture.width / 2, e.anchor.y = e.texture.height / 2, e.target.copy(this.target), this.addChild(e)
            }
        },
        _getVar: function(t) {
            return Math.random() * t * (Math.random() > .5 ? -1 : 1)
        },
        _removeParticle: function(t) {
            t.remove(), game.pool.put(this._poolName, t)
        }
    }), game.addAttributes("Particles", {
        poolName: "particle"
    }), game.createClass("Particle", "Sprite", {
        accel: null,
        deltaScale: 0,
        deltaAlpha: 0,
        emitter: null,
        life: 0,
        rotateAmount: 0,
        target: null,
        velocity: null,
        velRotate: 0,
        staticInit: function(t) {
            this.super(t), this.accel = new game.Vector, this.target = new game.Vector, this.velocity = new game.Vector
        },
        _update: function() {
            if (this.emitter) {
                if (this.life > 0 && (this.life -= 1e3 * game.delta, this.life <= 0)) return this.emitter._removeParticle(this);
                if (this.emitter.targetForce > 0) {
                    var t = this.emitter.targetUpdate ? this.emitter.target : this.target;
                    this.accel.set(t.x - this.position.x, t.y - this.position.y);
                    var e = Math.sqrt(this.accel.x * this.accel.x + this.accel.y * this.accel.y);
                    this.accel.x /= e || 1, this.accel.y /= e || 1, this.accel.x *= this.emitter.targetForce, this.accel.y *= this.emitter.targetForce
                }
                if (this.velocity.x += this.accel.x * game.delta, this.velocity.y += this.accel.y * game.delta, this.emitter.velocityLimit.x > 0 && (this.velocity.x > this.emitter.velocityLimit.x && (this.velocity.x = this.emitter.velocityLimit.x), this.velocity.x < -this.emitter.velocityLimit.x && (this.velocity.x = -this.emitter.velocityLimit.x)), this.emitter.velocityLimit.y > 0 && (this.velocity.y > this.emitter.velocityLimit.y && (this.velocity.y = this.emitter.velocityLimit.y), this.velocity.y < -this.emitter.velocityLimit.y && (this.velocity.y = -this.emitter.velocityLimit.y)), this.velRotate) {
                    var i = Math.cos(this.velRotate * game.delta),
                        a = Math.sin(this.velRotate * game.delta),
                        s = this.velocity.x * i - this.velocity.y * a,
                        r = this.velocity.y * i + this.velocity.x * a;
                    this.velocity.x = s, this.velocity.y = r
                }
                this.position.x += this.velocity.x * game.delta, this.position.y += this.velocity.y * game.delta, this.deltaAlpha && (this.alpha = Math.max(0, this.alpha + this.deltaAlpha * game.delta)), this.deltaScale && (this.scale.x += this.deltaScale * game.delta, this.scale.y += this.deltaScale * game.delta), this.rotateAmount && (this.rotation += this.rotateAmount * game.delta)
            }
        }
    })
});
game.module("engine.scene").body(function() {
    game.createClass("Scene", {
        backgroundColor: null,
        isMouseDown: !1,
        objects: [],
        paused: !1,
        stage: null,
        timers: [],
        tweens: [],
        _backgroundColorRgb: null,
        _mouseDownTime: null,
        _mouseDownX: null,
        _mouseDownY: null,
        _pausedObjects: [],
        _pausedTimers: [],
        _pausedTweens: [],
        _updateOrder: [],
        staticInit: function() {
            this.backgroundColor = this.backgroundColor || game.Scene.backgroundColor, !this.backgroundColor && game.device.cocoonCanvasPlus && (this.backgroundColor = "#000"), game.input._reset(), game.keyboard._reset(), game.scene = this, this.stage = new game.Container, this.stage.stage = this.stage;
            for (var e = 0; e < game.Scene.updateOrder.length; e++) this._updateOrder.push(game.Scene.updateOrder[e].ucfirst())
        },
        addObject: function(e) {
            -1 === this.objects.indexOf(e) && (e._remove = !1, this.objects.push(e))
        },
        click: function() {},
        exit: function() {},
        keydown: function() {},
        keyup: function() {},
        mousedown: function() {},
        mousemove: function() {},
        mouseout: function() {},
        mouseup: function() {},
        onPause: function() {},
        onResize: function() {},
        onResume: function() {},
        pause: function() {
            if (!this.paused) {
                this._pausedObjects.length = 0, this._pausedTimers.length = 0, this._pausedTweens.length = 0;
                for (var e = 0; e < this.objects.length; e++) this._pausedObjects.push(this.objects[e]);
                for (e = 0; e < this.timers.length; e++) this._pausedTimers.push(this.timers[e]);
                for (e = 0; e < this.tweens.length; e++) this._pausedTweens.push(this.tweens[e]);
                this.objects.length = 0, this.timers.length = 0, this.tweens.length = 0, this.paused = !0, this.onPause()
            }
        },
        removeObject: function(e) {
            e._remove = !0
        },
        removeTimer: function(e, s) {
            e && (s || (e.callback = null), e.repeat = !1, e.set(0))
        },
        removeTimers: function(e) {
            for (var s = this.timers.length - 1; s >= 0; s--) this.removeTimer(this.timers[s], e)
        },
        removeTweens: function() {
            for (var e = 0; e < this.tweens.length; e++) this.tweens[e]._shouldRemove = !0
        },
        resume: function() {
            if (this.paused) {
                for (var e = 0; e < this._pausedObjects.length; e++) this.objects.push(this._pausedObjects[e]);
                for (e = 0; e < this._pausedTimers.length; e++) this.timers.push(this._pausedTimers[e]);
                for (e = 0; e < this._pausedTweens.length; e++) this.tweens.push(this._pausedTweens[e]);
                this.paused = !1, this.onResume()
            }
        },
        swipe: function() {},
        update: function() {},
        _exit: function(e) {
            if (game.audio && game.Audio.stopOnSceneChange) {
                game.audio.stopMusic();
                for (var s = 0; s < game.audio.sounds.length; s++) game.audio.sounds[s].stop(!0)
            }
            return this.exit(e)
        },
        _mousedown: function(e, s, t, i) {
            this.isMouseDown = !0, this._mouseDownTime = game.Timer.time, this._mouseDownX = e, this._mouseDownY = s, this.mousedown(e, s, t, i)
        },
        _mousemove: function(e, s, t, i) {
            this.mousemove(e, s, t, i), this._mouseDownTime && (e - this._mouseDownX >= game.Scene.swipeDist ? this._swipe("RIGHT") : e - this._mouseDownX <= -game.Scene.swipeDist ? this._swipe("LEFT") : s - this._mouseDownY >= game.Scene.swipeDist ? this._swipe("DOWN") : s - this._mouseDownY <= -game.Scene.swipeDist && this._swipe("UP"))
        },
        _mouseup: function(e, s, t, i) {
            if (this.isMouseDown = !1, this._mouseDownTime) {
                var n = game.Timer.time - this._mouseDownTime;
                (0 === game.Input.clickTimeout || n < game.Input.clickTimeout) && this.click(e, s, t, i)
            }
            this._mouseDownTime = null, this.mouseup(e, s, t, i)
        },
        _pause: function() {
            game.audio && game.audio._systemPause()
        },
        _resume: function() {
            game.audio && game.audio._systemResume()
        },
        _swipe: function(e) {
            var s = game.Timer.time - this._mouseDownTime;
            this._mouseDownTime = null, (s <= game.Scene.swipeTime || 0 === game.Scene.swipeTime) && this.swipe(e)
        },
        _update: function() {
            for (var e = 0; e < this._updateOrder.length; e++) this["_update" + this._updateOrder[e]]()
        },
        _updateCollision: function() {
            this.paused || this.world && this.world._updateCollision()
        },
        _updateObjects: function() {
            for (var e = this.objects.length - 1; e >= 0; e--) "function" != typeof this.objects[e].update || this.objects[e]._remove || this.objects[e].update(), this.objects[e]._remove && this.objects.splice(e, 1)
        },
        _updatePhysics: function() {
            this.paused || this.world && this.world._update()
        },
        _updateRenderer: function() {
            game.renderer._render(this.stage)
        },
        _updateScene: function() {
            this.update()
        },
        _updateTimers: function() {
            for (var e = this.timers.length - 1; e >= 0; e--) 0 === this.timers[e].time() && ("function" == typeof this.timers[e].callback && this.timers[e].callback(), this.timers[e].repeat ? this.timers[e]._base = game.Timer.time : this.timers.splice(e, 1))
        },
        _updateTweens: function() {
            for (var e = this.tweens.length - 1; e >= 0; e--) this.tweens[e]._update() || this.tweens.splice(e, 1)
        }
    }), game.addAttributes("Scene", {
        backgroundColor: "#000",
        swipeDist: 100,
        swipeTime: 500,
        updateOrder: ["physics", "tweens", "collision", "timers", "scene", "objects", "renderer"]
    })
});
game.module("engine.loader").require("engine.scene").body(function() {
    game.createClass("Loader", "Scene", {
        loaded: 0,
        onComplete: null,
        percent: 0,
        scene: null,
        started: !1,
        totalFiles: 0,
        _error: null,
        _loadCount: 0,
        _loadedFiles: [],
        _queue: [],
        staticInit: function(e) {
            e && (this.scene = e, this.super());
            for (var t = 0; t < game.mediaQueue.length; t++) this._queue.push(game.mediaQueue[t]);
            return game.mediaQueue.length = 0, this.totalFiles = this._queue.length, 0 === this.totalFiles && (this.percent = 100), e && this.init(), !0
        },
        init: function() {
            if (this.backgroundColor = game.Loader.backgroundColor, game.Loader.showLogo && (this.logo = new game.Sprite(game.logo), this.logo.anchorCenter(), this.logo.x = game.width / 2, this.logo.y = game.height / 2, this.logo.addTo(this.stage), this.logoTween = game.Tween.add(this.logo.scale, {
                    x: 1.1,
                    y: 1.1
                }, 500, {
                    easing: "Quadratic.Out",
                    repeat: 1 / 0,
                    yoyo: !0
                }).start()), game.Loader.showPercent) {
                var e = 20;
                this.percentText = new game.SystemText("", {
                    size: e / game.scale,
                    align: "center",
                    color: game.Loader.textColor
                }), this.percentText.position.set(game.width / 2, game.height / 2 - e / game.scale + 7), this.percentText.addTo(this.stage)
            }
            game.Loader.text && (this.loaderText = new game.SystemText(game.Loader.text, {
                size: 14 / game.scale,
                align: "center",
                color: game.Loader.textColor
            }), this.loaderText.position.set(game.width / 2, game.height - e / game.scale), this.loaderText.addTo(this.stage)), this.onProgress()
        },
        generateFont: function(e, t) {
            game.Font.fromData(e), t()
        },
        loadAtlas: function(e, t) {
            this.loadFile(e, this.parseJSON.bind(this, e, t))
        },
        loadAudio: function(e, t) {
            game.Audio.enabled ? game.audio._load(e, t) : t()
        },
        loadFile: function(e, t) {
            var a = new XMLHttpRequest;
            game.device.WKWebView ? a.addEventListener("loadend", t.bind(this, a)) : (a.onload = t.bind(this, a), a.onerror = this._progress.bind(this, "Error loading file " + e)), a.open("GET", e), a.send()
        },
        loadFont: function(e, t) {
            this.loadFile(e, this.parseFont.bind(this, e, t))
        },
        loadImage: function(e, t) {
            game.BaseTexture.fromImage(e, function() {
                game.Loader.preRender && game.renderer.context.drawImage(this.source, 0, 0), t()
            })
        },
        loadJSON: function(e, t) {
            this.loadFile(e, this.parseJSON.bind(this, e, t))
        },
        onComplete: function() {
            this.scene && game.system.setScene(this.scene)
        },
        onError: function(e) {
            throw this.logoTween && this.logoTween.stop(), this.percentText && (this.percentText.color = game.Loader.errorColor), this.loaderText && (this.loaderText.color = game.Loader.errorColor, this.loaderText.text = e), e
        },
        onProgress: function() {
            this.percentText && (this.percentText.text = this.percent + "%")
        },
        onStart: function() {},
        parseAtlas: function(e, t) {
            var a = game._getFilePath(e.meta.image),
                s = game.BaseTexture.fromImage(a),
                i = e.frames;
            for (var o in i) {
                var r = i[o].frame || i[o],
                    n = r.x / game.scale,
                    l = r.y / game.scale,
                    g = r.w / game.scale,
                    h = r.h / game.scale,
                    d = new game.Texture(s, n, l, g, h);
                r.sx && (d._offset.x = r.sx), r.sy && (d._offset.y = r.sy), r.sw && (d._trim.x = r.sw), r.sh && (d._trim.y = r.sh), r.ax && (d._anchor.x = r.ax), r.ay && (d._anchor.y = r.ay), game.Texture.cache[o] = d
            }
            t()
        },
        parseFont: function(e, t, a) {
            a.responseText && 404 !== a.status || t("Error loading font " + e);
            var s = a.responseText.split("\n");
            if (-1 !== s[0].indexOf("xml")) {
                var i = a.responseXML;
                if (!i || /MSIE 9/i.test(navigator.userAgent) || navigator.isCocoonJS)
                    if ("function" == typeof window.DOMParser) {
                        i = (new DOMParser).parseFromString(a.responseText, "text/xml")
                    } else {
                        var o = document.createElement("div");
                        o.innerHTML = a.responseText, i = o
                    }
                var r = i.getElementsByTagName("page");
                if (r.length) {
                    var n = this._getFolder(e),
                        l = this._getFilePath(r[0].getAttribute("file"));
                    r[0].setAttribute("file", n + l);
                    var g = game._getFilePath(n + l);
                    this.loadImage(g, this.generateFont.bind(this, i, t))
                }
            } else {
                l = {
                    pages: [],
                    chars: [],
                    kernings: []
                };
                for (var h = 0; h < s.length; h++)
                    if (0 !== s[h].length) {
                        var d = s[h].split(" "),
                            m = d.shift();
                        if ("char" === m || "kerning" === m || "page" === m) {
                            for (var c = {}, u = 0; u < d.length; u++) {
                                c[(f = d[u].split("="))[0]] = f[1].replace(/['"]+/g, "")
                            }
                            l[m + "s"].push(c)
                        } else if ("chars" !== m && "kernings" !== m) {
                            l[m] = {};
                            for (u = 0; u < d.length; u++) {
                                var f = d[u].split("=");
                                l[m][f[0]] = f[1].replace(/['"]+/g, "")
                            }
                        }
                    }
                l.pages[0].file = this._getFilePath(l.pages[0].file);
                n = this._getFolder(e), g = game._getFilePath(n + l.pages[0].file);
                this.loadImage(g, this.generateFont.bind(this, l, t))
            }
        },
        parseJSON: function(e, t, a) {
            a.responseText && 404 !== a.status || t("Error loading JSON " + e);
            try {
                var s = JSON.parse(a.responseText)
            } catch (e) {
                return void t(e)
            }
            if (game.json[e] = s, s.frames) {
                s.meta.image = this._getFolder(e) + s.meta.image;
                var i = game._getFilePath(s.meta.image);
                this.loadImage(i, this.parseAtlas.bind(this, s, t))
            } else t()
        },
        start: function() {
            this.started = !0, this._startTime = game.Timer.time, this.onStart(), 100 === this.percent ? this._complete() : this._startLoading()
        },
        _complete: function() {
            if (this.totalFiles > 0 && game.scale > 1) {
                for (var e in game.BaseTexture.cache) e.indexOf("@" + game.scale + "x") >= 0 && (game.BaseTexture.cache[e.replace("@" + game.scale + "x", "")] = game.BaseTexture.cache[e], delete game.BaseTexture.cache[e]);
                for (var e in game.Texture.cache) e.indexOf("@" + game.scale + "x") >= 0 && (game.Texture.cache[e.replace("@" + game.scale + "x", "")] = game.Texture.cache[e], delete game.Texture.cache[e])
            }
            var t = game.Loader.minTime - (game.Timer.time - this._startTime);
            t > 0 ? game.Timer.add(t, this.onComplete.bind(this)) : this.onComplete()
        },
        _getFilePath: function(e) {
            return e.indexOf("@" + game.scale + "x.") >= 0 || e.indexOf(".svg") >= 0 ? e : game.scale > 1 ? e.replace(/\.(?=[^.]*$)/, "@" + game.scale + "x.") : e
        },
        _getFolder: function(e) {
            var t = e.substr((game.config.mediaFolder + "/").length);
            return t = t.substr(0, t.lastIndexOf("/") + 1)
        },
        _progress: function(e) {
            if (e) return this._error = e, this.onError(e);
            this._loadCount--, this.loaded++, this.percent = Math.round(this.loaded / this.totalFiles * 100), this.onProgress(), this.loaded === this.totalFiles ? this._complete() : this._startLoading()
        },
        _startLoading: function() {
            this._queue.reverse();
            for (var e = this._queue.length - 1; e >= 0; e--) {
                var t = this._queue[e];
                if (t) {
                    var a = t.split("?").shift().split(".").pop().toLowerCase(),
                        s = game.Loader.formats[a];
                    if (!this[s])
                        for (e = game.Audio.formats.length - 1; e >= 0; e--) a !== game.Audio.formats[e].ext || (s = "loadAudio");
                    if ("loadImage" !== s && "loadAtlas" !== s && "loadFont" !== s || (t = this._getFilePath(t)), this._loadCount++, this._queue.splice(e, 1), this._loadedFiles.push(t), this[s] ? this[s](t, this._progress.bind(this)) : this.onError("Unsupported file format " + a), this._loadCount === game.Loader.maxFiles) return
                }
            }
        },
        _update: function() {
            this.super(), this.scene && !this.started && this.start()
        }
    }), game.addAttributes("Loader", {
        backgroundColor: "#000",
        errorColor: "#ff0000",
        formats: {
            atlas: "loadAtlas",
            png: "loadImage",
            jpg: "loadImage",
            jpeg: "loadImage",
            json: "loadJSON",
            fnt: "loadFont",
            svg: "loadImage"
        },
        maxFiles: 4,
        minTime: 500,
        preRender: !1,
        showLogo: !0,
        showPercent: !0,
        text: "Made with Panda 2 - www.panda2.io",
        textColor: "#fff"
    })
});
game.module("engine.input").body(function() {
    game.createClass("Input", {
        items: [],
        motion: null,
        mouse: null,
        touches: [],
        _currentCursor: null,
        _mouseDownItem: null,
        _mouseDownTime: null,
        _mouseMoveItem: null,
        _mouseUpItem: null,
        _needUpdate: !1,
        init: function(e) {
            this.mouse = new game.Vector;
            var t = game.device.cocoonCanvasPlus ? window : e;
            t.addEventListener("touchstart", this._touchstart.bind(this)), t.addEventListener("touchmove", this._touchmove.bind(this)), t.addEventListener("touchend", this._touchend.bind(this)), t.addEventListener("touchcancel", this._touchend.bind(this)), t.addEventListener("mousedown", this._mousedown.bind(this)), t.addEventListener("mousemove", this._mousemove.bind(this)), t.addEventListener("mouseout", this._mouseout.bind(this)), window.addEventListener("blur", this._mouseout.bind(this)), window.addEventListener("mouseup", this._mouseup.bind(this)), game.device.mobile && window.addEventListener("devicemotion", this._devicemotion.bind(this))
        },
        _calculateXY: function(e) {
            var t = game.renderer.canvas.getBoundingClientRect(),
                s = (e.clientX - t.left) * (game.renderer.canvas.width / t.width),
                n = (e.clientY - t.top) * (game.renderer.canvas.height / t.height);
            e.canvasX = s / game.scale, e.canvasY = n / game.scale
        },
        _devicemotion: function(e) {
            this.motion = e
        },
        _hitTest: function(e, t, s) {
            var n = e.hitArea;
            if (n) {
                var i = e._worldTransform,
                    o = e._getBounds(),
                    a = o.x || i.tx,
                    u = o.y || i.ty,
                    m = Math.abs(i.a / e._cosCache),
                    h = Math.abs(i.d / e._cosCache),
                    c = e.anchor.x / e.width || 0,
                    r = e.anchor.y / e.height || 0,
                    d = a + n.x * m,
                    _ = u + n.y * h;
                if (d += o.width * m * c, _ += o.height * h * r, n.radius) {
                    var v = n.radius / 2,
                        l = t - (d += v),
                        f = s - (_ += v);
                    return Math.sqrt(l * l + f * f) < v
                }
                var g = n.width * m,
                    w = n.height * h
            } else d = (n = e._getBounds()).x, _ = n.y, g = n.width, w = n.height;
            return t >= d && s >= _ && t <= d + g && s <= _ + w
        },
        _mousedown: function(e) {
            game.Input.focusOnMouseDown && window.focus(), game.scene && (this._preventDefault(e), this._calculateXY(e), this.mouse.set(e.canvasX, e.canvasY), this._mouseDownItem = this._processEvent("mousedown", e), this._mouseDownTime = game.Timer.time, game.scene._mousedown(e.canvasX, e.canvasY, e.identifier, e))
        },
        _mousemove: function(e) {
            if (game.scene) {
                this._preventDefault(e), this._calculateXY(e), this.mouse.set(e.canvasX, e.canvasY);
                var t = this._processEvent("mousemove", e);
                this._updateCursor(t), this._mouseMoveItem && this._mouseMoveItem !== t && this._mouseMoveItem.mouseout(e.canvasX, e.canvasY, e.identifier, e), t && this._mouseMoveItem !== t && t.mouseover(e.canvasX, e.canvasY, e.identifier, e), this._mouseMoveItem = t, game.scene._mousemove(e.canvasX, e.canvasY, e.identifier, e)
            }
        },
        _mouseout: function(e) {
            game.scene && (this._mouseMoveItem && this._mouseMoveItem.mouseout(e.canvasX, e.canvasY, e.identifier, e), this._mouseMoveItem = null, game.scene.mouseout(e))
        },
        _mouseup: function(e) {
            if (game.scene) {
                if (this._preventDefault(e), this._calculateXY(e), e.canvasX < 0 || e.canvasX > game.width || e.canvasY < 0 || e.canvasY > game.height) return this._mouseDownItem && this._mouseDownItem.mouseupoutside(e.canvasX, e.canvasY, e.identifier, e), void game.scene._mouseup(e.canvasX, e.canvasY, e.identifier, e);
                if (this.mouse.set(e.canvasX, e.canvasY), this._mouseUpItem = this._processEvent("mouseup", e), this._mouseDownItem && this._mouseDownItem === this._mouseUpItem) {
                    var t = game.Timer.time - this._mouseDownTime;
                    (0 === game.Input.clickTimeout || t < game.Input.clickTimeout) && this._mouseDownItem.click(e.canvasX, e.canvasY, e.identifier, e)
                }
                this._mouseDownItem && this._mouseDownItem !== this._mouseUpItem && this._mouseDownItem.mouseupoutside(e.canvasX, e.canvasY, e.identifier, e), game.scene._mouseup(e.canvasX, e.canvasY, e.identifier, e)
            }
        },
        _preventDefault: function(e) {
            e.preventDefault && game.Input.preventDefault && e.preventDefault()
        },
        _processEvent: function(e, t) {
            for (var s = this.items.length - 1; s >= 0; s--) {
                var n = this.items[s];
                if (n._interactive && n.visible && (this._hitTest(n, t.canvasX, t.canvasY) && !n[e](t.canvasX, t.canvasY, t.identifier, t))) return n
            }
        },
        _reset: function() {
            this.items.length = 0, this._mouseDownItem = null, this._mouseMoveItem = null, this._mouseUpItem = null
        },
        _touchend: function(e) {
            this._preventDefault(e);
            for (var t = 0; t < e.changedTouches.length; t++) {
                var s = e.changedTouches[t]; - 1 !== this.touches.indexOf(s.identifier) && (this._mouseup(s), this.touches.erase(s.identifier))
            }
        },
        _touchmove: function(e) {
            this._preventDefault(e);
            for (var t = 0; t < e.changedTouches.length; t++) {
                var s = e.changedTouches[t]; - 1 !== this.touches.indexOf(s.identifier) && this._mousemove(s)
            }
        },
        _touchstart: function(e) {
            this._preventDefault(e);
            for (var t = 0; t < e.changedTouches.length; t++) {
                if (1 === this.touches.length && !game.Input.multitouch) return;
                var s = e.changedTouches[t];
                this.touches.push(s.identifier), this._mousedown(s)
            }
        },
        _update: function() {
            this._needUpdate && (this.items.length = 0, this._updateItems(game.scene.stage), this._needUpdate = !1)
        },
        _updateCursor: function(e) {
            if (!game.device.mobile) {
                var t = "inherit";
                e && e.buttonMode && (t = game.Input.buttonModeCursor), this._currentCursor !== t && (this._currentCursor = t, game.renderer.canvas.style.cursor = this._currentCursor)
            }
        },
        _updateItems: function(e) {
            for (var t = 0; t < e.children.length; t++) {
                var s = e.children[t];
                s._interactive && this.items.push(s), s.children.length && this._updateItems(s)
            }
        }
    }), game.addAttributes("Input", {
        buttonModeCursor: "pointer",
        clickTimeout: 500,
        focusOnMouseDown: !0,
        multitouch: !0,
        preventDefault: !0
    }), game.createClass("Keyboard", {
        _keysDown: [],
        init: function() {
            window.addEventListener("keydown", this._keydown.bind(this)), window.addEventListener("keyup", this._keyup.bind(this)), window.addEventListener("blur", this._reset.bind(this))
        },
        down: function(e) {
            return !!this._keysDown[e]
        },
        _keydown: function(e) {
            if ((document.activeElement === document.body || document.activeElement === game.renderer.canvas) && game.system._running) {
                var t = game.Keyboard.keys[e.keyCode];
                if (t || (t = e.keyCode), this._keysDown[t]) return e.preventDefault();
                if (this._keysDown[t] = !0, game.scene && game.scene.keydown) game.scene.keydown(t, this.down("SHIFT"), this.down("CTRL"), this.down("ALT")) && e.preventDefault()
            }
        },
        _keyup: function(e) {
            if (game.system._running) {
                var t = game.Keyboard.keys[e.keyCode];
                t || (t = e.keyCode), this._keysDown[t] = !1, game.scene && game.scene.keyup && game.scene.keyup(t)
            }
        },
        _reset: function() {
            for (var e in this._keysDown) this._keysDown[e] = !1
        }
    }), game.addAttributes("Keyboard", {
        keys: {
            8: "BACKSPACE",
            9: "TAB",
            13: "ENTER",
            16: "SHIFT",
            17: "CTRL",
            18: "ALT",
            19: "PAUSE",
            20: "CAPS_LOCK",
            27: "ESC",
            32: "SPACE",
            33: "PAGE_UP",
            34: "PAGE_DOWN",
            35: "END",
            36: "HOME",
            37: "LEFT",
            38: "UP",
            39: "RIGHT",
            40: "DOWN",
            44: "PRINT_SCREEN",
            45: "INSERT",
            46: "DELETE",
            48: "0",
            49: "1",
            50: "2",
            51: "3",
            52: "4",
            53: "5",
            54: "6",
            55: "7",
            56: "8",
            57: "9",
            65: "A",
            66: "B",
            67: "C",
            68: "D",
            69: "E",
            70: "F",
            71: "G",
            72: "H",
            73: "I",
            74: "J",
            75: "K",
            76: "L",
            77: "M",
            78: "N",
            79: "O",
            80: "P",
            81: "Q",
            82: "R",
            83: "S",
            84: "T",
            85: "U",
            86: "V",
            87: "W",
            88: "X",
            89: "Y",
            90: "Z",
            96: "NUM_ZERO",
            97: "NUM_ONE",
            98: "NUM_TWO",
            99: "NUM_THREE",
            100: "NUM_FOUR",
            101: "NUM_FIVE",
            102: "NUM_SIX",
            103: "NUM_SEVEN",
            104: "NUM_EIGHT",
            105: "NUM_NINE",
            106: "NUM_MULTIPLY",
            107: "NUM_PLUS",
            109: "NUM_MINUS",
            110: "NUM_PERIOD",
            111: "NUM_DIVISION",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            186: "SEMICOLON",
            187: "PLUS",
            189: "MINUS",
            192: "GRAVE_ACCENT",
            222: "SINGLE_QUOTE"
        }
    })
});
game.module("engine.geometry").body(function() {
    game.createClass("Arc", {
        endAngle: 0,
        radius: 0,
        startAngle: 0,
        x: 0,
        y: 0,
        staticInit: function(t, i, n, s, e) {
            this.startAngle = s || this.startAngle, this.endAngle = e || this.endAngle, this.radius = t || this.radius, this.x = i || this.x, this.y = n || this.y
        }
    }), game.createClass("Circle", {
        radius: 0,
        x: 0,
        y: 0,
        staticInit: function(t, i, n) {
            this.radius = t || this.radius, this.x = i || this.x, this.y = n || this.y
        }
    }), game.createClass("Rectangle", {
        height: 0,
        width: 0,
        x: 0,
        y: 0,
        staticInit: function(t, i, n, s) {
            this.set(t, i, n, s)
        },
        set: function(t, i, n, s) {
            this.width = "number" == typeof t ? t : this.width, this.height = "number" == typeof i ? i : this.width, this.x = "number" == typeof n ? n : this.x, this.y = "number" == typeof s ? s : this.y
        }
    }), game.createClass("Vector", {
        x: 0,
        y: 0,
        staticInit: function(t, i) {
            this.set(t, i)
        },
        add: function(t, i) {
            return this.x += t instanceof game.Vector ? t.x : t, this.y += t instanceof game.Vector ? t.y : i || (0 !== i ? t : 0), this
        },
        angle: function(t) {
            return t instanceof game.Vector ? Math.atan2(t.y - this.y, t.x - this.x) : Math.atan2(this.y, this.x)
        },
        angleFromOrigin: function(t) {
            return Math.atan2(t.y, t.x) - Math.atan2(this.y, this.x)
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        compare: function(t) {
            return this.x === t.x && this.y === t.y
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this
        },
        distance: function(t, i) {
            return i = (t = t instanceof game.Vector ? t.x : t) instanceof game.Vector ? t.y : i || (0 !== i ? t : 0), t -= this.x, i -= this.y, Math.sqrt(t * t + i * i)
        },
        divide: function(t, i) {
            return this.x /= t instanceof game.Vector ? t.x : t, this.y /= t instanceof game.Vector ? t.y : i || (0 !== i ? t : 0), this
        },
        dot: function(t) {
            return t instanceof game.Vector ? this.x * t.x + this.y * t.y : this.x * this.x + this.y * this.y
        },
        dotNormalized: function(t) {
            var i = this.length(),
                n = this.x / i,
                s = this.y / i;
            if (t instanceof game.Vector) {
                var e = t.length();
                return n * (t.x / e) + s * (t.y / e)
            }
            return n * n + s * s
        },
        length: function() {
            return Math.sqrt(this.dot())
        },
        limit: function(t) {
            return this.x = this.x.limit(-t.x, t.x), this.y = this.y.limit(-t.y, t.y), this
        },
        multiply: function(t, i) {
            return this.x *= t instanceof game.Vector ? t.x : t, this.y *= t instanceof game.Vector ? t.y : i || (0 !== i ? t : 0), this
        },
        multiplyAdd: function(t, i) {
            return this.x += t instanceof game.Vector ? t.x * i : t * i, this.y += t instanceof game.Vector ? t.y * i : t * i, this
        },
        normalize: function() {
            var t = this.length();
            return this.x /= t || 1, this.y /= t || 1, this
        },
        rotate: function(t) {
            var i = Math.cos(t),
                n = Math.sin(t),
                s = this.x * i - this.y * n,
                e = this.y * i + this.x * n;
            return this.x = s, this.y = e, this
        },
        round: function(t) {
            return this.x = this.x.round(t), this.y = this.y.round(t), this
        },
        set: function(t, i) {
            return this.x = "number" == typeof t ? t : this.x, this.y = "number" == typeof i ? i : this.x, this
        },
        subtract: function(t, i) {
            return this.x -= t instanceof game.Vector ? t.x : t, this.y -= t instanceof game.Vector ? t.y : i || (0 !== i ? t : 0), this
        }
    })
});
game.module("engine.camera").body(function() {
    game.createClass("Camera", {
        acceleration: 3,
        limit: null,
        maxSpeed: 200,
        offset: null,
        position: null,
        rounding: !1,
        sensorPosition: null,
        sensorSize: null,
        speed: null,
        threshold: 1,
        _container: null,
        _target: null,
        staticInit: function(t) {
            this.limit = new game.Rectangle(1 / 0, 1 / 0, -1 / 0, -1 / 0), this.position = new game.Vector, this.speed = new game.Vector, this.offset = new game.Vector(game.width / 2, game.height / 2), this.sensorPosition = new game.Vector(this.offset.x, this.offset.y), this.sensorSize = new game.Vector(200), t && this.setTarget(t)
        },
        addTo: function(t) {
            return this._container = t, this._container.position.set(-this.position.x, -this.position.y), this._setSensorPosition(), this
        },
        setTarget: function(t) {
            this._target = t, this._setSensorPosition()
        },
        setPosition: function(t, i) {
            (t instanceof game.Vector || t instanceof game.Container) && (i = t.y, t = t.x), this._container && (t *= this._container.scale.x, i *= this._container.scale.y), this._setPosition(t, i)
        },
        update: function() {
            this._moveSensor(), this._moveCamera()
        },
        _moveCamera: function() {
            this.speed.x = (this.position.x - this.sensorPosition.x + this.offset.x).limit(-this.maxSpeed, this.maxSpeed), this.speed.y = (this.position.y - this.sensorPosition.y + this.offset.y).limit(-this.maxSpeed, this.maxSpeed), this.speed.x > this.threshold || this.speed.x < -this.threshold || this.speed.y > this.threshold || this.speed.y < -this.threshold ? this._setPosition(this.position.x + this.offset.x - this.speed.x * this.acceleration * game.delta, this.position.y + this.offset.y - this.speed.y * this.acceleration * game.delta) : this.speed.set(0, 0)
        },
        _moveSensor: function() {
            if (this._target && this._container) {
                var t = this._target.width * this._container.scale.x,
                    i = this._target.height * this._container.scale.y,
                    s = (this._target.position.x - this._target.anchor.x + this._target.width / 2 * this._target.scale.x) * this._container.scale.x,
                    e = (this._target.position.y - this._target.anchor.y + this._target.height / 2 * this._target.scale.y) * this._container.scale.y;
                (this.sensorSize.x < t || this.sensorSize.y < i) && this.sensorSize.set(t, i), s < this.sensorPosition.x - this.sensorSize.x / 2 + t / 2 ? this.sensorPosition.x = s + this.sensorSize.x / 2 - t / 2 : s + (this.sensorSize.x / 2 + t / 2) > this.sensorPosition.x + this.sensorSize.x && (this.sensorPosition.x = s + (this.sensorSize.x / 2 + t / 2) - this.sensorSize.x), e < this.sensorPosition.y - this.sensorSize.y / 2 + i / 2 ? this.sensorPosition.y = e + this.sensorSize.y / 2 - i / 2 : e + (this.sensorSize.y / 2 + i / 2) > this.sensorPosition.y + this.sensorSize.y && (this.sensorPosition.y = e + (this.sensorSize.y / 2 + i / 2) - this.sensorSize.y)
            }
        },
        _setPosition: function(t, i) {
            this.position.set(t - this.offset.x, i - this.offset.y), this.position.x < this.limit.x ? (this.position.x = this.limit.x, this.speed.x = 0) : this.position.x > this.limit.width && (this.position.x = this.limit.width, this.speed.x = 0), this.position.y < this.limit.y ? (this.position.y = this.limit.y, this.speed.y = 0) : this.position.y > this.limit.height && (this.position.y = this.limit.height, this.speed.y = 0), this._container && (this._container.position.x = -(this.rounding ? this.position.x + .5 | 0 : this.position.x), this._container.position.y = -(this.rounding ? this.position.y + .5 | 0 : this.position.y))
        },
        _setSensorPosition: function() {
            if (this._target && this._container) {
                var t = (this._target.position.x - this._target.anchor.x + this._target.width / 2 * this._target.scale.x) * this._container.scale.x,
                    i = (this._target.position.y - this._target.anchor.y + this._target.height / 2 * this._target.scale.y) * this._container.scale.y;
                this.sensorPosition.set(t, i)
            }
        }
    })
});
game.module("engine.audio").body(function() {
    game.createClass("Audio", {
        formats: [],
        music: null,
        muted: !1,
        sounds: [],
        _context: null,
        _mainGain: null,
        _musicGain: null,
        _pauseMusic: null,
        _pauseSounds: [],
        _soundGain: null,
        staticInit: function() {
            if (game.Audio.enabled) {
                game._normalizeVendorAttribute(window, "AudioContext");
                for (var t = new Audio, e = 0; e < game.Audio.formats.length; e++) t.canPlayType(game.Audio.formats[e].type) && this.formats.push(game.Audio.formats[e].ext);
                this.formats.length ? window.AudioContext && (this._context = new AudioContext, this._mainGain = this._context.createGain(), this._mainGain.connect(this._context.destination), this._musicGain = this._context.createGain(), this._musicGain.gain.setValueAtTime(game.Audio.musicVolume, this._context.currentTime), this._musicGain.connect(this._mainGain), this._soundGain = this._context.createGain(), this._soundGain.gain.setValueAtTime(game.Audio.soundVolume, this._context.currentTime), this._soundGain.connect(this._mainGain)) : game.Audio.enabled = !1
            }
        },
        mute: function() {
            this._mainGain && (this._mainGain.gain.setValueAtTime(0, this._context.currentTime), this.muted = !0)
        },
        playMusic: function(t) {
            return new game.Music(t).play()
        },
        playSound: function(t, e, i) {
            var s = new game.Sound(t);
            return s.volume = e || s.volume, s.rate = i || s._rate, s.play(), s
        },
        stopAll: function() {
            this.stopMusic();
            for (var t = 0; t < this.sounds.length; t++) this.sounds[t].stop()
        },
        stopMusic: function() {
            this.music && this.music.stop(), this.music = null
        },
        toggle: function() {
            return this.muted ? this.unmute() : this.mute(), this.muted
        },
        unmute: function() {
            this._mainGain && (this._mainGain.gain.setValueAtTime(1, this._context.currentTime), this.muted = !1)
        },
        _decode: function(t, e, i) {
            this._context.decodeAudioData(t.response, this._loaded.bind(this, e, i), this._error.bind(this, e, i))
        },
        _error: function(t, e) {
            e("Error loading audio " + t)
        },
        _load: function(t, e) {
            if (game.Audio.enabled) {
                var i = t.split("?").shift().split(".").pop(); - 1 === this.formats.indexOf(i) && (i = this.formats[0]);
                var s = t.replace(/[^\.]+$/, i + game._nocache);
                if (window.AudioContext) {
                    var n = new XMLHttpRequest;
                    n.open("GET", s, !0), n.responseType = "arraybuffer", n.onload = this._decode.bind(this, n, t, e), n.send()
                } else {
                    var o = new Audio;
                    o.src = s, this._loaded(t, e, o)
                }
            } else e()
        },
        _loaded: function(t, e, i) {
            var s = game._getId(t);
            game.Audio.cache[s] = i, e()
        },
        _systemPause: function() {
            this.music && this.music.playing && (this.music.pause(), this._pauseMusic = this.music);
            for (var t = 0; t < this.sounds.length; t++) this.sounds[t].playing && (this.sounds[t].pause(), this._pauseSounds.push(this.sounds[t]))
        },
        _systemResume: function() {
            this._pauseMusic && this._pauseMusic.resume();
            for (var t = 0; t < this._pauseSounds.length; t++) this._pauseSounds[t].resume();
            this._pauseMusic = null, this._pauseSounds.length = 0
        }
    }), game.addAttributes("Audio", {
        cache: {},
        clearCache: function() {
            for (var t in this.cache) delete this.cache[t]
        },
        enabled: !0,
        formats: [{
            ext: "ogg",
            type: 'audio/ogg; codecs="vorbis"'
        }, {
            ext: "m4a",
            type: 'audio/mp4; codecs="mp4a.40.5"'
        }, {
            ext: "wav",
            type: "audio/wav"
        }],
        loopEnd: 0,
        loopStart: 0,
        musicVolume: 1,
        soundVolume: 1,
        stopOnSceneChange: !0
    }), game.createClass("Sound", {
        loop: !1,
        muted: !1,
        onComplete: null,
        paused: !1,
        playing: !1,
        _buffer: null,
        _context: null,
        _gainNode: null,
        _rate: 1,
        _source: null,
        _volume: 1,
        staticInit: function(t) {
            if (!game.Audio.enabled) return !0;
            if (this._buffer = game.Audio.cache[t], !this._buffer) throw "Audio " + t + " not found";
            window.AudioContext && (this._context = game.audio._context, this._gainNode = this._context.createGain())
        },
        init: function() {
            this._gainNode && this._gainNode.connect(game.audio._soundGain), this.volume = game.Audio.soundVolume
        },
        fadeIn: function(t) {
            this._fade(t, this.volume)
        },
        fadeOut: function(t) {
            this._fade(t, 0)
        },
        mute: function() {
            this._gainNode ? this._gainNode.gain.setValueAtTime(0, this._context.currentTime) : this._source.volume = 0, this.muted = !0
        },
        pause: function() {
            this._source && (this.paused || this.playing && (this.stop(), this.paused = !0, this._source.pauseTime = (this._context.currentTime - this._source.startTime) % this._buffer.duration))
        },
        play: function(t, e, i) {
            if (this._buffer) return this._onStart(), this.playing = !0, t = t || 0, e = e || 0, i = i || this._buffer.duration - e, this._context ? this._source = this._context.createBufferSource() : this._source = this._buffer, this._source.buffer = this._buffer, this._source.loop = this.loop, this._source.playbackRate && this._source.playbackRate.setValueAtTime(this.rate, this._context.currentTime), this._source.onended = this._onComplete.bind(this), this._source.connect && (this._source.connect(this._gainNode), this._source.startTime = this._context.currentTime - e), this._context ? this.loop ? (this._source.loopStart = game.Audio.loopStart, this._source.loopEnd = this._source.buffer.duration - game.Audio.loopEnd, this._source.start(this._context.currentTime + t, e)) : this._source.start(this._context.currentTime + t, e, i) : (this._source.volume = this.volume, this._source.currentTime = 0, this._source.play()), this
        },
        resume: function() {
            this._source && this.paused && (this.paused = !1, this._source.pauseTime && this.play(0, this._source.pauseTime))
        },
        stop: function(t) {
            this._source && (this.paused || (this.playing = !1, t && (this.onComplete = null), this._context ? "number" == typeof this._source.playbackState && 2 !== this._source.playbackState || this._source.stop() : this._source.pause()))
        },
        unmute: function() {
            this._gainNode ? this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime) : this._source.volume = this._volume, this.muted = !1
        },
        _fade: function(t, e) {
            if (this._buffer) {
                t = (t || 1e3) / 1e3;
                var i = this._context.currentTime;
                e === this.volume && this._gainNode.gain.setValueAtTime(0, this._context.currentTime);
                var s = this._gainNode.gain.value;
                this._gainNode.gain.linearRampToValueAtTime(s, i), this._gainNode.gain.linearRampToValueAtTime(e, i + t)
            }
        },
        _onComplete: function() {
            game.audio.sounds.erase(this), this.paused || "function" == typeof this.onComplete && this.onComplete()
        },
        _onStart: function() {
            this.stop(), game.audio.sounds.push(this)
        }
    }), game.defineProperties("Sound", {
        rate: {
            get: function() {
                return this._rate
            },
            set: function(t) {
                this._rate = t, this._source && (this._source.playbackRate.value = t)
            }
        },
        volume: {
            get: function() {
                return this._volume
            },
            set: function(t) {
                this._volume = t, this._gainNode && this._gainNode.gain.setValueAtTime(t, this._context.currentTime)
            }
        }
    }), game.createClass("Music", "Sound", {
        loop: !0,
        init: function() {
            this._gainNode && this._gainNode.connect(game.audio._musicGain), this.volume = game.Audio.musicVolume
        },
        _onStart: function() {
            game.audio.music && game.audio.music.stop(), game.audio.music = this
        }
    })
});
game.config = {
    "system": {
        "width": 768,
        "height": 1024,
        "scale": true,
        "center": true,
        "resize": false
    },
    "mobile": {},
    "ignoreModules": ["engine.debug"]
};
game.module("plugin.essentials").require("engine.renderer.text").body(function() {
    this.version = "1.1.0", game.isStarted || (game.createClass("Button", {
        callback: null,
        clickSound: null,
        disableAlpha: .5,
        fadeSpeed: 500,
        rotateAmount: .1,
        rotateEasing: "Quadratic.InOut",
        rotateSpeed: 1e3,
        scaleAmount: .1,
        scaleEasing: "Back.Out",
        scaleSound: null,
        scaleSpeed: 250,
        staticInit: function(t, e, i, s) {
            this.sprite = new game.Sprite(t), this.sprite.anchorCenter(), this.sprite.position.set(e, i), this.sprite.interactive = !0, this.sprite.mousedown = this._mousedown.bind(this), this.sprite.mouseup = this.sprite.mouseupoutside = this._mouseup.bind(this), this.sprite.click = this._click.bind(this), this.sprite.buttonMode = !0, this.callback = s, this.clickSound = game.Button.clickSound, this.scaleSound = game.Button.scaleSound
        },
        addTo: function(t) {
            t.addChild(this.sprite)
        },
        disable: function() {
            this.sprite.alpha = this.disableAlpha, this.sprite.interactive = !1
        },
        enable: function() {
            this.sprite.alpha = 1, this.sprite.interactive = !0
        },
        fadeIn: function(t) {
            t = t || 0, this.sprite.alpha = 0, this.sprite.visible = !0, game.Tween.add(this.sprite, {
                alpha: 1
            }, this.fadeSpeed, {
                delay: t,
                onComplete: this._fadeInComplete.bind(this)
            }).start()
        },
        fadeOut: function(t, e) {
            t = t || 0, this.sprite.alpha = 1, this.sprite.interactive = !1, game.Tween.add(this.sprite, {
                alpha: 0
            }, this.fadeSpeed, {
                delay: t,
                onComplete: this._fadeOutComplete.bind(this, e)
            }).start()
        },
        remove: function() {
            this.sprite.remove(), this.rotateTween && this.rotateTween.stop()
        },
        rotate: function(t) {
            this.sprite.rotation = -this.rotateAmount, this.rotateTween = game.Tween.add(this.sprite, {
                rotation: this.rotateAmount
            }, this.rotateSpeed, {
                repeat: 1 / 0,
                yoyo: !0,
                easing: this.rotateEasing
            }).start(), t && (this.rotateTween.currentTime = this.rotateTween.duration.random())
        },
        scaleIn: function(t) {
            this.sprite.interactive = !1, t = t || 0, this.sprite.scale.set(0), game.Tween.add(this.sprite.scale, {
                x: 1,
                y: 1
            }, this.scaleSpeed, {
                easing: this.scaleEasing,
                delay: t,
                onStart: this._onScaleInStart.bind(this),
                onComplete: this._scaleInEnd.bind(this)
            }).start()
        },
        _click: function() {
            this.sprite.alpha < 1 || (this.clickSound && game.audio.playSound(this.clickSound), "function" == typeof this.callback && this.callback())
        },
        _fadeOutComplete: function(t) {
            t && (this.sprite.visible = !1)
        },
        _fadeInComplete: function() {
            this.sprite.interactive = !0
        },
        _mousedown: function() {
            this.sprite.alpha < 1 || this.sprite.scale.set(1 - this.scaleAmount)
        },
        _mouseup: function() {
            this.sprite.scale.set(1)
        },
        _onScaleInStart: function() {
            this.scaleSound && game.audio.playSound(this.scaleSound)
        },
        _scaleInEnd: function() {
            this.sprite.interactive = !0
        }
    }), game.addAttributes("Button", {
        clickSound: null,
        scaleSound: null
    }), game.createClass("Fader", {
        color: "#000",
        delay: 0,
        speed: 500,
        sprite: null,
        target: null,
        staticInit: function(t) {
            game.merge(this, t), this.sprite = new game.Graphics, this.sprite.drawRect(0, 0, game.width, game.height)
        },
        fadeIn: function(t) {
            this.sprite.shapes[0].fillColor = this.color, this.sprite.addTo(this.target || game.scene.stage), this.sprite.alpha = 1, game.Tween.add(this.sprite, {
                alpha: 0
            }, this.speed, {
                delay: this.delay,
                onComplete: this._fadeInComplete.bind(this, t)
            }).start()
        },
        fadeOut: function(t) {
            this.sprite.shapes[0].fillColor = this.color, this.sprite.addTo(this.target || game.scene.stage), this.sprite.alpha = 0, game.Tween.add(this.sprite, {
                alpha: 1
            }, this.speed, {
                delay: this.delay,
                onComplete: this._fadeOutComplete.bind(this, t)
            }).start()
        },
        _fadeInComplete: function(t) {
            this.sprite.remove(), "function" == typeof t && t()
        },
        _fadeOutComplete: function(t) {
            "function" == typeof t && t()
        }
    }), game.createClass("IconButton", "Button", {
        staticInit: function(t, e, i, s, a) {
            this.super(t, i, s, a), this.icon = new game.Sprite(e), this.icon.anchorCenter(), this.icon.center(this.sprite), this.icon.addTo(this.sprite)
        },
        setIcon: function(t) {
            this.icon.setTexture(t), this.icon.center(this.sprite)
        }
    }), game.createClass("TextButton", "Button", {
        staticInit: function(t, e, i, s, a, n) {
            this.super(t, i, s, a), this.text = new game.Text(e, n), this.text.anchorCenter(), this.text.center(this.sprite), this.text.addTo(this.sprite)
        }
    }), game.createClass("CircleText", "Text", {
        radius: 100,
        speed: 1,
        _count: 0,
        update: function() {
            this._count += this.speed * game.delta;
            for (var t = 2 * Math.PI / this.children.length, e = 0, i = 0; i < this.children.length; i++) {
                var s = this.children[i];
                s.x = this.radius * Math.cos(e + this._count), s.y = this.radius * Math.sin(e + this._count), e += t
            }
        }
    }), game.createClass("WaveText", "Text", {
        advance: 3,
        amount: 10,
        speed: 10,
        _count: 0,
        _pos: [],
        _generateText: function(t) {
            this.super(t), this._pos.length = 0;
            for (var e = 0; e < this.children.length; e++) {
                var i = this.children[e];
                this._pos.push(i.y)
            }
        },
        update: function() {
            this._count += 50 * game.delta;
            for (var t = 0; t < this.children.length; t++) {
                var e = this.children[t],
                    i = (this._count + t * this.advance) / this.speed;
                e.y = this._pos[t] + Math.sin(i) * this.amount
            }
        }
    }))
});
game.module("game.main").require("plugin.essentials").body(function() {
    game.addAsset("button.png"), game.addAsset("font_normal.fnt"), game.addAsset("icon_settings.png"), game.createScene("Main", {
        backgroundColor: "#474747",
        init: function() {
            var t, e;
            (t = new game.Button("button.png", game.width / 2, 120, function() {
                console.log("Button clicked")
            })).scaleIn(), t.rotate(!0), t.addTo(this.stage), (e = new game.Text("Button")).x = game.width / 2 - e.width / 2, e.y = 20, e.addTo(this.stage), (t = new game.IconButton("button.png", "icon_settings.png", game.width / 2, 300, function() {
                console.log("Button clicked")
            })).scaleIn(200), t.rotate(!0), t.addTo(this.stage), (e = new game.Text("IconButton")).x = game.width / 2 - e.width / 2, e.y = 200, e.addTo(this.stage), (t = new game.TextButton("button.png", "OK", game.width / 2, 500, function() {
                console.log("Button clicked")
            })).scaleIn(400), t.rotate(!0), t.addTo(this.stage), (e = new game.Text("TextButton")).x = game.width / 2 - e.width / 2, e.y = 400, e.addTo(this.stage), (e = new game.WaveText("This is WaveText")).x = game.width / 2 - e.width / 2, e.y = 600, e.addTo(this.stage), (e = new game.CircleText("This is CircleText")).x = game.width / 2, e.y = 800, e.addTo(this.stage);
            var n = new game.Fader;
            n.speed = 1e3, n.fadeIn()
        }
    })
});